<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[交并补]]></title>
    <url>%2Fblog%2F2019%2F08%2F13%2F%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%2F%E9%9B%86%E5%90%88%2F%E4%BA%A4%E9%9B%86-%E5%B9%B6%E9%9B%86-%E8%A1%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[&#x601D;&#x8DEF; &#x5C06;&#x96C6;&#x5408;&#x7684;&#x5143;&#x7D20;&#x7528;map&#x8FDB;&#x884C;&#x5B58;&#x50A8;&#xFF0C;key&#x4E3A;&#x96C6;&#x5408;&#x7684;&#x5143;&#x7D20;&#xFF0C;value&#x4E3A;1. &#x5BF9;&#x4E8E;&#x4EA4;&#x96C6;&#x904D;&#x5386;&#x5176;&#x4E2D;&#x4E00;&#x4E2A;&#x96C6;&#x5408;&#xFF08;&#x9009;&#x62E9;&#x957F;&#x5EA6;&#x8F83;&#x5C0F;&#x7684;&#x597D;&#x4E9B;&#xFF09;&#xFF0C;&#x5982;&#x679C;&#x53E6;&#x4E00;&#x4E2A;&#x96C6;&#x5408;&#x5B58;&#x5728;&#x8FD9;&#x4E2A;&#x5143;&#x7D20;&#xFF0C;&#x5219;&#x8BE5;&#x5143;&#x7D20;&#x662F;&#x4EA4;&#x96C6;&#x4E2D;&#x7684;&#x5143;&#x7D20;&#x3002; &#x5BF9;&#x4E8E;&#x5E76;&#x96C6;&#xFF0C;&#x5148;&#x53D6;&#x4E00;&#x4E2A;&#x96C6;&#x5408;B&#x4F5C;&#x4E3A;&#x5E76;&#x96C6;&#x7684;&#x7ED3;&#x679C;&#xFF0C;&#x5BF9;A&#x505A;&#x904D;&#x5386;&#xFF0C;&#x5982;&#x679C;B&#x4E2D;&#x4E0D;&#x5B58;&#x5728;&#x8BE5;&#x5143;&#x7D20;&#xFF0C;&#x5219;&#x8BE5;&#x5143;&#x7D20;&#x662F;&#x5E76;&#x96C6;&#x4E2D;&#x7684;&#x5143;&#x7D20;&#x3002; &#x5BF9;&#x4E8E;&#x8865;&#x96C6;&#xFF0C;&#x5982;&#x6C42;A&#x7684;&#x8865;&#x96C6;&#xFF0C;&#x5BF9;B&#x505A;&#x904D;&#x5386;&#xFF0C;&#x5982;&#x679C;A&#x4E2D;&#x4E0D;&#x5B58;&#x5728;&#x8BE5;&#x5143;&#x7D20;&#xFF0C;&#x5219;&#x8BE5;&#x5143;&#x7D20;&#x662F;&#x8865;&#x96C6;&#x4E2D;&#x7684;&#x5143;&#x7D20;&#x3002; &#x4EE3;&#x7801;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;iostream&gt;using namespace std;#include&lt;map&gt;template&lt;class T&gt;T* intersectionSet(T *setA,int lenA,T * setB,int lenB,int &amp;lenC){ // &#x6C42;&#x4E24;&#x4E2A;&#x96C6;&#x5408;&#x7684;&#x4EA4;&#x96C6; // &#x5C06;&#x96C6;&#x5408;&#x7684;&#x5143;&#x7D20;&#x7528;map&#x8FDB;&#x884C;&#x5B58;&#x50A8;&#xFF0C;&#x7136;&#x540E;&#x5BF9;&#x5176;&#x4E2D;&#x4E00;&#x4E2A;&#xFF08;&#x957F;&#x5EA6;&#x5C0F;&#x7684;&#x597D;&#x4E9B;&#xFF09;&#x904D;&#x5386;&#xFF0C;&#x67E5;&#x770B;&#x53E6;&#x4E00;&#x4E2A;&#x662F;&#x5426;&#x5B58;&#x5728;&#x8BE5;&#x6570;&#xFF0C;&#x5B58;&#x5728;&#x7684;&#x5373;&#x4E3A;&#x4EA4;&#x96C6;&#x4E2D;&#x7684;&#x6570; map&lt;T,int&gt; mapA; map&lt;T,int&gt; mapB; for(int i=0;i&lt;lenA;i++){ mapA.insert(pair&lt;T, int&gt;(setA[i],1)); } for(int i=0;i&lt;lenB;i++){ mapB.insert(pair&lt;T, int&gt;(setB[i],1)); } T temp[lenA]; int k=0; typename std::map&lt;T,int&gt;::iterator iter; for( iter = mapA.begin(); iter != mapA.end(); iter++){ // cout&lt;&lt;&quot;A i is &quot;&lt;&lt; iter-&gt;first&lt;&lt;&quot; &quot;; // cout&lt;&lt;mapB[iter-&gt;first]&lt;&lt;endl; if(mapB[iter-&gt;first] == 1){ temp[k++] = iter-&gt;first; } } // cout&lt;&lt;endl; T * re = new T[k]; memcpy(re,temp,k*sizeof(T)); lenC = k; return re;}template&lt;class T&gt;T* unionSet(T *setA,int lenA,T * setB,int lenB,int &amp;lenC){ // lenC &#x5E76;&#x96C6;&#x7684;&#x5143;&#x7D20;&#x4E2A;&#x6570; // &#x6C42;&#x4E24;&#x4E2A;&#x96C6;&#x5408;&#x7684;&#x5E76;&#x96C6; // &#x5C06;&#x96C6;&#x5408;&#x7684;&#x5143;&#x7D20;&#x7528;map&#x8FDB;&#x884C;&#x5B58;&#x50A8;&#xFF0C; map&lt;T,int&gt; mapA; map&lt;T,int&gt; mapB; T temp[lenA&gt;lenB?lenA:lenB]; for(int i=0;i&lt;lenA;i++){ mapA.insert(pair&lt;T, int&gt;(setA[i],1)); } for(int i=0;i&lt;lenB;i++){ mapB.insert(pair&lt;T, int&gt;(setB[i],1)); temp[i] = setB[i]; } int k=lenB; typename std::map&lt;T,int&gt;::iterator iter; for( iter = mapA.begin(); iter != mapA.end(); iter++){ if(mapB[iter-&gt;first] == 0){ temp[k++] = iter-&gt;first; } } // cout&lt;&lt;endl; T * re = new T[k]; memcpy(re,temp,k*sizeof(T)); lenC = k; return re;}template&lt;class T&gt;T* complementarySet(T *setA,int lenA,T * setB,int lenB,int &amp;lenC){ // &#x6C42;&#x4E24;&#x4E2A;&#x96C6;&#x5408;&#x7684;&#x8865;&#x96C6; // &#x5C06;&#x96C6;&#x5408;&#x7684;&#x5143;&#x7D20;&#x7528;map&#x8FDB;&#x884C;&#x5B58;&#x50A8;&#xFF0C; map&lt;T,int&gt; mapA; map&lt;T,int&gt; mapB; for(int i=0;i&lt;lenA;i++){ mapA.insert(pair&lt;T, int&gt;(setA[i],1)); } for(int i=0;i&lt;lenB;i++){ mapB.insert(pair&lt;T, int&gt;(setB[i],1)); } T temp[lenB]; int k=0; typename std::map&lt;T,int&gt;::iterator iter; for( iter = mapB.begin(); iter != mapB.end(); iter++){ // cout&lt;&lt;&quot;A i is &quot;&lt;&lt; iter-&gt;first&lt;&lt;&quot; &quot;; // cout&lt;&lt;mapB[iter-&gt;first]&lt;&lt;endl; if(mapA[iter-&gt;first] == 0){ temp[k++] = iter-&gt;first; } } // cout&lt;&lt;endl; T * re = new T[k]; memcpy(re,temp,k*sizeof(T)); lenC = k; return re;}int main(){ // int setA[] = {1,0,3,4,5}; // int setB[] = {1,2,3,4,5,6,7}; // int *setC = unionSet(setA,5,setB,7); // for(int i=0;i&lt;4;i++){ // cout&lt;&lt;setC[i]&lt;&lt;&quot;\t&quot;; // } char setA[] = {&apos;1&apos;,&apos;d&apos;,&apos;a&apos;,&apos;c&apos;,&apos;2&apos;}; char setB[] = {&apos;1&apos;,&apos;d&apos;,&apos;i&apos;,&apos;a&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;}; int lenC = 0; char *setI = intersectionSet(setA,5,setB,7,lenC); cout&lt;&lt;&quot;intersectionSet &quot;&lt;&lt;endl; for(int i=0;i&lt;lenC;i++){ cout&lt;&lt;setI[i]&lt;&lt;&quot;\t&quot;; } cout&lt;&lt;endl&lt;&lt;&quot;unionSet &quot;; cout&lt;&lt;endl; char *setU = unionSet(setA,5,setB,7,lenC); for(int i=0;i&lt;lenC;i++){ cout&lt;&lt;setU[i]&lt;&lt;&quot;\t&quot;; } cout&lt;&lt;endl; cout&lt;&lt;endl&lt;&lt;&quot;A complementarySet &quot;; cout&lt;&lt;endl; char *setC = complementarySet(setA,5,setB,7,lenC); for(int i=0;i&lt;lenC;i++){ cout&lt;&lt;setC[i]&lt;&lt;&quot;\t&quot;; } cout&lt;&lt;endl; delete setI; delete setU; delete setC; return 0;} &#x7ED3;&#x679C;123456intersectionSet 1 2 a d unionSet 1 d i a 2 3 4 c complementarySet 3 4 i]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>交并补</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cart - 决策树（回归树与分类树）python]]></title>
    <url>%2Fblog%2F2019%2F08%2F13%2F%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2Fcart%2Fcart%2F</url>
    <content type="text"><![CDATA[&#x5148;&#x8D34;&#x4EE3;&#x7801;&#xFF0C;&#x540E;&#x9762;&#x518D;&#x8865;&#x8BF4;&#x660E; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257import numpy as npfrom showtree import *###1 &#x627E;&#x6700;&#x4F73;&#x5207;&#x5206;&#x70B9;&#xFF1A;# &#x5BF9;&#x6BCF;&#x7EF4;&#x7279;&#x5F81;&#xFF1A;# &#x6BCF;&#x4E2A;&#x7279;&#x5F81;&#x503C;&#xFF1A;# &#x5C06;&#x6570;&#x636E;&#x5207;&#x5206;2&#x4EFD;&#xFF0C;&#x5206;&#x522B;&#x8BA1;&#x7B97;&#x8BEF;&#x5DEE;&#xFF0C;&#x4FDD;&#x7559;&#x6700;&#x5C0F;&#x8BEF;&#x5DEE;#2 &#x6267;&#x884C;&#x4E8C;&#x5143;&#x5207;&#x5206;#3 &#x53F3;&#x5B50;&#x6811;&#x8C03;&#x7528;createTree()#4 &#x5DE6;&#x5B50;&#x6811;&#x8C03;&#x7528;createTree()#def loadData(filepath,split_char = &apos;\t&apos;,floats = False): # &#x52A0;&#x8F7D;&#x6570;&#x636E;&#x96C6; dataSet = [] with open(filepath) as file: for line in file.readlines(): currline = line.strip().split(split_char)# &#x53BB;&#x524D;&#x540E;&#x7A7A;&#x683C; &#x8F6C;&#x6570;&#x7EC4; fltLine = [] for i in currline: if floats: fltLine.append(float(i)) else: fltLine.append(i) dataSet.append(fltLine) return dataSetdef calGini(dataSet,labelindex): # &#x6839;&#x636E;&#x6807;&#x7B7E;&#x8BA1;&#x7B97;gini&#x6307;&#x6570; # labelindex &#x6807;&#x7B7E;&#x6240;&#x5728;&#x7684;&#x5217; # print(dataSet,labelindex) num = len(dataSet) labelCounts = {} for label in dataSet[:,labelindex]: if label not in labelCounts.keys(): labelCounts[label] = 1 else: labelCounts[label] +=1 gini = 1 # print(labelCounts) for label in labelCounts: prop = float(labelCounts[label])/num gini -=prop*prop # print(gini) return ginidef getAllVar(dataSet,labelindex): # dataSet np.array &#x6BCF;&#x5217;&#x8868;&#x793A;&#x7279;&#x5F81;&#xFF0C;&#x6700;&#x540E;&#x4E00;&#x5217;&#x8868;&#x793A;&#x6807;&#x7B7E;&#xFF0C;&#x6BCF;&#x884C;&#x8868;&#x793A;&#x4E00;&#x884C;&#x6570;&#x636E; # &#x8BA1;&#x7B97;labelindex &#x5217;&#x7684;&#x65B9;&#x5DEE; return np.var(dataSet[:,labelindex])def getMeanLeaf(dataSet,labelindex,ctype = 1): # &#x83B7;&#x5F97;&#x53F6;&#x5B50;&#x8282;&#x70B9; if ctype == 1: # print(dataSet) # print(&quot;leaf&quot;,dataSet.shape) # &#x8868;&#x51B3;&#x53D6;&#x503C; lab = {} for i in dataSet[:,labelindex]: if i not in lab.keys(): lab[i] = 0; lab[i]+=1 sortedClassCount = sorted(lab, reverse=False) print(&quot;lab&quot;,lab) print(&quot;sort&quot;,sortedClassCount) print(&quot;sort&quot;,sortedClassCount[0]) return sortedClassCount[0] return np.mean(dataSet[:,labelindex]) # labelindex&#xFF08;&#x6807;&#x7B7E;&#xFF09;&#x7684;&#x5E73;&#x5747;&#x503C;def createTree(dataSet,features,labelindex=-1,ctype = 1,ops = (1,1),delfeat = True): # ctype = 0 &#x8868;&#x793A;&#x6C42;&#x56DE;&#x5F52;&#x6811; # ctype = 1 &#x8868;&#x793A;&#x6C42;&#x5206;&#x7C7B;&#x6811; # index,val = chooseBestSplit(dataSet,features,labelindex,ctype,ops) if index == None or len(features) == 0: return val tree = {} tree[features[index]] = {} arr0,arr1 = splitdataSet(dataSet,index,val,delfeat = delfeat) print(arr0) if delfeat: subfeatures = [features[i] for i in range(len(features)) if i != index] else: subfeatures = features[:] tree[features[index]][val] = createTree(arr0,subfeatures,labelindex=-1,ctype = ctype,ops=ops) # right = createTree(arr1,subfeatures,labelindex=-1,ctype = ctype,ops=ops) tree[features[index]][&apos;others&apos;] = createTree(arr1,subfeatures,labelindex=-1,ctype = ctype,ops=ops) return treedef splitdataSet(dataSet,index,value,ctype = 1,delfeat=True): # ctype = 0 &#x8868;&#x793A;&#x6C42;&#x56DE;&#x5F52;&#x6811; # ctype = 1 &#x8868;&#x793A;&#x6C42;&#x5206;&#x7C7B;&#x6811; # &#x56DE;&#x5F52;&#x6811;&#x7684;&#x5212;&#x5206;&#x6570;&#x636E;&#x96C6; # &#x5C06;&#x6570;&#x636E;&#x96C6;dataSet &#x6309;&#x7167;index&#x5217;&#x7684;value&#x8FDB;&#x884C;&#x5207;&#x5206; # print(&quot;index value&quot;,dataSet,index,value) if ctype == 0: arr0 = dataSet[np.squeeze(dataSet[:,index]&lt;value),:] arr1 = dataSet[np.squeeze(dataSet[:,index]&gt;=value),:] else: arr0 = dataSet[np.squeeze(dataSet[:,index] == value),:] arr1 = dataSet[np.squeeze(dataSet[:,index]!=value),:] if delfeat: tem = [True]*np.shape(arr0)[1] tem[index] = False arr0 = arr0[:,tem] arr1 = arr1[:,tem] return arr0,arr1def _test_splitdataSet(): data_list, feat_list = create_samples() data_list = np.array(data_list) arr0,arr1 = splitdataSet(data_list,1,&apos;yes&apos;,1) print(arr0) print(arr1)def chooseBestSplit(dataSet,features=[],labelindex=-1,ctype = 1,ops = (1,0)): # leafctype &#x5404;&#x81EA;&#x8282;&#x70B9;&#x7684;&#x51FD;&#x6570; &#x8F93;&#x5165;&#x4E3A;dataSet # errctype &#x8BA1;&#x7B97;&#x8BEF;&#x5DEE;&#x7684;&#x51FD;&#x6570; &#x53C2;&#x6570;&#x4E3A;dataSet &#x5982;gini&#x6307;&#x6570;&#x7B49; # ops &#x8C03;&#x8282;&#x53C2;&#x6570; &#x4E8C;&#x5143;&#x7EC4;[0] &#x8868;&#x793A;&#x8BEF;&#x5DEE;&#x6539;&#x53D8;&#x7684;&#x6700;&#x5C0F;&#x503C; [1] &#x5207;&#x5206;&#x7684;&#x6700;&#x5C0F;&#x6570;&#x636E;&#x6761;&#x6570; # &#x8FD4;&#x56DE;&#x6700;&#x4F73;&#x5207;&#x5206;&#x7684;&#x4F4D;&#x7F6E;&#x548C;&#x503C; &#x82E5;&#x4E0D;&#x80FD;&#x5207;&#x5206; &#x8FD4;&#x56DE;None &#x548C;&#x5F53;&#x524D;&#x6570;&#x636E;&#x7684;&#x5E73;&#x5747;&#x503C; leafctype = getMeanLeaf if ctype == 0: gini_fn = getAllVar else: gini_fn = calGini # print(dataSet) # print(dataSet.shape) if dataSet.shape[0] == 1 or len(set(dataSet[:,labelindex].T.tolist()))==1: return None,leafctype(dataSet,labelindex,ctype=1) m,n = np.shape(dataSet) # m &#x884C; n &#x5217; bestError = 99999 bestIndex = 0 bestVal = dataSet[0,0] lastError = gini_fn(dataSet,labelindex) for index in range(n-1): for value in set(dataSet[:,index]): # print(&quot;value&quot;,value) arr0,arr1 = splitdataSet(dataSet,index,value,ctype) # &#x5982;&#x679C;&#x6570;&#x636E;&#x96C6;&#x5F88;&#x5C0F;&#x5C31;&#x4E0D;&#x5207;&#x5206; if np.shape(arr0)[0] &lt; ops[1] or np.shape(arr1)[0] &lt; ops[1]: continue if ctype == 0: newError = gini_fn(arr0,labelindex) + gini_fn(arr1,labelindex) else: pro0 = float(len(arr0))/float(len(dataSet)) pro1 = float(len(arr1))/float(len(dataSet)) newError = pro0 * gini_fn(arr0,labelindex) + pro1 * gini_fn(arr1,labelindex) # try: # print(&quot;newError&quot;,features[index],value,newError) # except IndexError as e: # print(&quot;-----------------------------------------------&quot;,e) # print(features,index) if newError &lt; bestError: bestError = newError bestVal = value bestIndex = index # &#x5982;&#x679C;&#x8BEF;&#x5DEE;&#x51CF;&#x5C0F;&#x91CF;&#x6BD4;&#x8F83;&#x5C0F;&#xFF0C;&#x5C31;&#x4E0D;&#x5207;&#x5206; # if lastError - bestError &lt; ops[0]: # return None,leafctype(dataSet,labelindex) arr0,arr1 = splitdataSet(dataSet,bestIndex,bestVal,ctype) # &#x5982;&#x679C;&#x6570;&#x636E;&#x96C6;&#x5F88;&#x5C0F;&#x5C31;&#x4E0D;&#x5207;&#x5206; if (np.shape(arr0)[0] &lt; ops[1]) or (np.shape(arr1)[0] &lt; ops[1]): print(np.shape(arr0)[0],ops[1],np.shape(arr1)[0]) return None,leafctype(dataSet,labelindex,ctype=1) print(&quot;best&quot;,bestIndex,bestVal) return bestIndex,bestValdef create_samples(): &apos;&apos;&apos;&apos;&apos; &#x63D0;&#x4F9B;&#x8BAD;&#x7EC3;&#x6837;&#x672C;&#x96C6; &#x6BCF;&#x4E2A;example&#x7531;&#x591A;&#x4E2A;&#x7279;&#x5F81;&#x503C;+1&#x4E2A;&#x5206;&#x7C7B;&#x6807;&#x7B7E;&#x503C;&#x7EC4;&#x6210; &#x6BD4;&#x5982;&#x7B2C;&#x4E00;&#x4E2A;example=[&apos;youth&apos;, &apos;no&apos;, &apos;no&apos;, &apos;1&apos;, &apos;refuse&apos;],&#x6B64;&#x6837;&#x672C;&#x7684;&#x542B;&#x4E49;&#x53EF;&#x4EE5;&#x89E3;&#x8BFB;&#x4E3A;&#xFF1A; &#x5982;&#x679C;&#x4E00;&#x4E2A;&#x4EBA;&#x7684;&#x6761;&#x4EF6;&#x662F;&#xFF1A;youth age&#xFF0C;no working, no house, &#x4FE1;&#x8A89;&#x503C;credit&#x4E3A;1 &#x5219;&#x6B64;&#x7C7B;&#x4EBA;&#x4F1A;&#x88AB;&#x5206;&#x7C7B;&#x5230;refuse&#x4E00;&#x7C7B;&#x4E2D;&#xFF0C;&#x5373;&#x5728;&#x76F8;&#x4EB2;&#x4E2D;&#x88AB;&#x62D2;&#x7EDD;(&#x4E5F;&#x53EF;&#x4EE5;&#x7406;&#x89E3;&#x4E3A;&#x94F6;&#x884C;&#x62D2;&#x7EDD;&#x4E3A;&#x6B64;&#x4EBA;&#x8D37;&#x6B3E;) &#x6BCF;&#x4E2A;example&#x7684;&#x7279;&#x5F81;&#x503C;&#x7C7B;&#x578B;&#x4E3A;&#xFF1A; [&apos;age&apos;, &apos;working&apos;, &apos;house&apos;, &apos;credit&apos;] &#x6BCF;&#x4E2A;example&#x7684;&#x5206;&#x7C7B;&#x6807;&#x7B7E;class_label&#x53D6;&#x503C;&#x8303;&#x56F4;&#x4E3A;&#xFF1A;&apos;refuse&apos;&#x6216;&#x8005;&apos;agree&apos; &apos;&apos;&apos; data_list = [[&apos;youth&apos;, &apos;no&apos;, &apos;no&apos;, &apos;1&apos;, &apos;refuse&apos;], [&apos;youth&apos;, &apos;no&apos;, &apos;no&apos;, &apos;2&apos;, &apos;refuse&apos;], [&apos;youth&apos;, &apos;yes&apos;, &apos;no&apos;, &apos;2&apos;, &apos;agree&apos;], [&apos;youth&apos;, &apos;yes&apos;, &apos;yes&apos;, &apos;1&apos;, &apos;agree&apos;], [&apos;youth&apos;, &apos;no&apos;, &apos;no&apos;, &apos;1&apos;, &apos;refuse&apos;], [&apos;mid&apos;, &apos;no&apos;, &apos;no&apos;, &apos;1&apos;, &apos;refuse&apos;], [&apos;mid&apos;, &apos;no&apos;, &apos;no&apos;, &apos;2&apos;, &apos;refuse&apos;], [&apos;mid&apos;, &apos;yes&apos;, &apos;yes&apos;, &apos;2&apos;, &apos;agree&apos;], [&apos;mid&apos;, &apos;no&apos;, &apos;yes&apos;, &apos;3&apos;, &apos;agree&apos;], [&apos;mid&apos;, &apos;no&apos;, &apos;yes&apos;, &apos;3&apos;, &apos;agree&apos;], [&apos;elder&apos;, &apos;no&apos;, &apos;yes&apos;, &apos;3&apos;, &apos;agree&apos;], [&apos;elder&apos;, &apos;no&apos;, &apos;yes&apos;, &apos;2&apos;, &apos;agree&apos;], [&apos;elder&apos;, &apos;yes&apos;, &apos;no&apos;, &apos;2&apos;, &apos;agree&apos;], [&apos;elder&apos;, &apos;yes&apos;, &apos;no&apos;, &apos;3&apos;, &apos;agree&apos;], [&apos;elder&apos;, &apos;no&apos;, &apos;no&apos;, &apos;1&apos;, &apos;refuse&apos;]] feat_list = [&apos;age&apos;, &apos;working&apos;, &apos;house&apos;, &apos;credit&apos;] return data_list, feat_listdef print_dict(src_dict, level=0, src_dict_namestr=&apos;&apos;): &apos;&apos;&apos;https://blog.csdn.net/u012421852/article/details/79840409 &#x9010;&#x884C;&#x6253;&#x5370;dict :param self:&#x7C7B;&#x5B9E;&#x4F8B;&#x81EA;&#x8EAB; :param src_dict:&#x88AB;&#x6253;&#x5370;&#x7684;dict :param level:&#x9012;&#x5F52;level&#xFF0C;&#x521D;&#x6B21;&#x8C03;&#x7528;&#x4E3A;level=0 :param src_dict_namestr:&#x5BF9;&#x8C61;&#x53D8;&#x91CF;&#x540D;&#x79F0;&#x5B57;&#x7B26;&#x4E32; &apos;&apos;&apos; if isinstance(src_dict, dict): tab_str = &apos;\t&apos; for i in range(level): tab_str += &apos;\t&apos; if 0 == level: print(src_dict_namestr,&apos;= {&apos;) for key, value in src_dict.items(): if isinstance(value, dict): has_dict = False for k,v in value.items(): if isinstance(v, dict): has_dict = True if has_dict: print(tab_str,key,&quot;:{&quot;) print_dict(value, level + 1) else: print(tab_str,key,&apos;:&apos;,value) else: print(tab_str,key,&apos;: &apos;,value,) print(tab_str,&apos;}&apos;) if __name__ == &quot;__main__&quot;: # file = &apos;test01.txt&apos; # dataSet = loadData(file,floats = False) # dataSet = np.array(dataSet) # features = [&quot;animal&quot;,&quot;temperature&quot;,&quot;cover&quot;,&quot;viviparity&quot;,&quot;egg&quot;,&quot;fly&quot;,&quot;water&quot;,&quot;leg&quot;,&quot;hibernate&quot;] # delfeat = True # tree = createTree(dataSet,features,ctype = 1,ops = (1,1),delfeat=delfeat) # print_dict(tree,0) # createPlot(tree)# dataset https://archive.ics.uci.edu/ml/datasets/Car+Evaluation file = &apos;car.data&apos; dataSet = loadData(file,split_char = &apos;,&apos;,floats = False) dataSet = np.array(dataSet) features = [&quot;buying&quot;,&quot;maint&quot;,&quot;doors&quot;,&quot;persons&quot;,&quot;lug_boot&quot;,&quot;safety&quot;] delfeat = True tree = createTree(dataSet,features,ctype = 1,ops = (1,5),delfeat=delfeat) print_dict(tree,0) createPlot(tree) # data_list, feat_list = create_samples() # data_list = np.array(data_list) # tree = createTree(data_list,ctype = 1,features = feat_list) # print_dict(tree,0) # createPlot(tree) # &#x6548;&#x679C;&#x56FE; &#x4EE3;&#x7801;&#x548C;&#x6570;&#x636E; &#x8FD9;&#x91CC;]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>决策树</tag>
        <tag>cart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[boost 提升树]]></title>
    <url>%2Fblog%2F2019%2F08%2F13%2F%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2Fboost%2Fboost%2F</url>
    <content type="text"><![CDATA[boost&#x63D0;&#x5347;&#x6811;&#x7B97;&#x6CD5;&#x601D;&#x60F3;&#x6BCF;&#x6B21;&#x505A;&#x56DE;&#x5F52;&#x65F6;&#xFF0C;&#x90FD;&#x5BF9;&#x4E0A;&#x6B21;&#x7684;&#x6B8B;&#x5DEE;&#xFF08;&#x4E5F;&#x5C31;&#x662F;&#x6807;&#x7B7E;&#x4E0E;&#x9884;&#x6D4B;&#x503C;&#x5F97;&#x5DEE;&#xFF09;&#x505A;&#x56DE;&#x5F52;&#xFF0C;&#x7528;&#x6B8B;&#x5DEE;&#x5E73;&#x65B9;&#x548C;&#x5F53;&#x505A;&#x635F;&#x5931;&#x51FD;&#x6570;&#xFF0C;&#x5BFB;&#x627E;&#x635F;&#x5931;&#x51FD;&#x6570;&#x6700;&#x5C0F;&#x7684;&#x5207;&#x5206;&#x70B9;&#xFF0C;&#x5F53;&#x505A;&#x8BE5;&#x56DE;&#x5F52;&#x6811;&#x7684;&#x5207;&#x5206;&#x70B9;&#x3002;&#x8FED;&#x4EE3;&#x8FDB;&#x884C;&#xFF0C;&#x5F97;&#x5230;&#x591A;&#x68F5;&#x56DE;&#x5F52;&#x6811;&#xFF0C;&#x9884;&#x6D4B;&#x7684;&#x7ED3;&#x679C;&#x5C31;&#x662F;&#x591A;&#x9897;&#x56DE;&#x5F52;&#x6811;&#x7684;&#x7D2F;&#x52A0;&#x548C;&#x3002; &#x4EE3;&#x7801;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223# coding = utf-8# boost &#x63D0;&#x5347;&#x6811;# # &#x601D;&#x60F3;&#xFF1A;# &#x521D;&#x59CB;&#x6B8B;&#x5DEE;&#x7B49;&#x4E8E;&#x6807;&#x7B7E;y&#x503C;&#xFF0C;&#x6BCF;&#x6B21;&#x5BF9;&#x6B8B;&#x5DEE;&#x505A;&#x4E8C;&#x5206;&#x56DE;&#x5F52;&#xFF0C;&#x5C06;&#x5168;&#x90E8;&#x7684;&#x56DE;&#x5F52;&#x6811;&#x7684;&#x9884;&#x6D4B;&#x7ED3;&#x679C;&#x7D2F;&#x52A0;&#x5373;&#x4E3A;&#x6700;&#x7EC8;&#x7684;&#x56DE;&#x5F52;&#x7ED3;&#x679C;# # &#x4EE3;&#x7801;&#x53C2;&#x8003; https://blog.csdn.net/slx_share/article/details/80112573# &#x56DE;&#x5F52;&#x63D0;&#x5347;&#x6811;import numpy as npimport matplotlib.pyplot as pltclass BoostTree(object): # &#x6570;&#x636E;&#x4E3A;np.array &#x6700;&#x540E;&#x4E00;&#x5217;&#x4E3A;y def __init__(self): self.epsilon = 1e-10 self.residual = None self.baseClassifier = [] # &#x56DE;&#x5F52;&#x6811;&#x7684;&#x96C6;&#x5408; self.dataSet = None self.best_split = None # &#x6700;&#x540E;&#x4E00;&#x4E2A;&#x56DE;&#x5F52;&#x6811;&#x7684;&#x5207;&#x5206;&#x4FE1;&#x606F; def _updata_residual(self): # &#x66F4;&#x65B0;&#x6B8B;&#x5DEE; if self.residual is None: self.residual = self.dataSet[:,-1] # (1,&#x6837;&#x672C;&#x4E2A;&#x6570;M) else: self.residual = self.dataSet[:,-1]-self._predict(self.dataSet) def _split_best(self): # &#x627E;&#x5207;&#x5206;&#x70B9; min_res_square = 99999999 best_index = 0 best_val = 0 best_val_left = 0 best_val_right = 0 for index in range(self.dataSet.shape[1]-1): for value in self.dataSet[:,index]: # value &#x53EF;&#x4EE5;&#x53D8;&#x4E3A; value + value_next/2 &#x6216; (value + value_next)/2&#x7B49; left = self.residual[self.dataSet[:,index]&lt;value] right = self.residual[self.dataSet[:,index]&gt;=value] if left.shape[0] == 0 or right.shape[0] == 0: continue # &#x8BA1;&#x7B97;&#x5DE6;&#x53F3;&#x4E24;&#x8FB9;&#x7684;&#x56DE;&#x5F52;&#x503C; &#x8FD9;&#x91CC;&#x7528;&#x5E73;&#x5747;&#x503C;&#x4EE3;&#x66FF; regress_left = np.mean(left) regress_right = np.mean(right) # &#x8BA1;&#x7B97;&#x6B8B;&#x5DEE; residual_left = left - regress_left residual_right = right - regress_right residual = np.append(residual_left,residual_right) # &#x8BA1;&#x7B97;&#x5F53;&#x524D;&#x5207;&#x5206;&#x7684;&#x6B8B;&#x5DEE;&#x7684;&#x5E73;&#x65B9;&#x548C; # var_resi = np.power(residual,2).sum() var_resi = np.dot(residual,residual.T) if var_resi &lt; min_res_square: min_res_square = var_resi best_index = index best_val = value best_val_left = regress_left best_val_right = regress_right split = {} split[&apos;index&apos;] = best_index split[&apos;best_val&apos;] = best_val split[&apos;best_val_left&apos;] = best_val_left split[&apos;best_val_right&apos;] = best_val_right self.best_split = split self.baseClassifier.append(split) return min_res_square def _predict(self,dataSet): # &#x9884;&#x6D4B; # &#x5BF9;&#x6240;&#x6709;&#x7684;&#x56DE;&#x5F52;&#x503C;&#x7684;&#x7D2F;&#x52A0;&#x548C; # dataSet np.array &#x53EF;&#x4EE5;&#x6CA1;&#x6709;&#x6807;&#x7B7E; # &#x8FD4;&#x56DE;&#x9884;&#x6D4B;&#x7684;&#x7ED3;&#x679C; size =&gt; (1,M) &#x4E00;&#x884C; M&#x4E2A;&#x6570; pre_data = np.zeros(dataSet.shape[0]) temp = np.zeros(dataSet.shape[0]) for _split in self.baseClassifier: temp[dataSet[:,_split[&apos;index&apos;]]&lt;_split[&apos;best_val&apos;]] = _split[&apos;best_val_left&apos;] temp[dataSet[:,_split[&apos;index&apos;]]&gt;=_split[&apos;best_val&apos;]] = _split[&apos;best_val_right&apos;] pre_data +=temp return pre_data def train(self,dataSet,maxIter = 1000,minErr = 0.01): # &#x6784;&#x5EFA;boost # dataSet np.array &#x6700;&#x540E;&#x4E00;&#x5217;&#x4E3A;&#x6807;&#x7B7E;y self.dataSet = dataSet self._updata_residual() for i in range(maxIter): # &#x8BA1;&#x7B97;&#x5207;&#x5206;&#x7684;&#x6B8B;&#x5DEE;&#x7684;&#x5E73;&#x65B9;&#x548C; min_res_square = self._split_best() # &#x66F4;&#x65B0;&#x6B8B;&#x5DEE; self._updata_residual() # &#x5C0F;&#x4E8E;&#x9884;&#x5B9A;&#x7684;&#x8BEF;&#x5DEE;&#xFF0C;&#x5219;&#x9000;&#x51FA;&#x5FAA;&#x73AF; if min_res_square &lt; minErr: break if i % 100 == 0: print(&quot;iter {} err is {}&quot;.format(i,min_res_square)) return def _sse(self,dataSet): # &#x8BA1;&#x7B97;&#x8BEF;&#x5DEE;&#x5E73;&#x65B9;&#x548C; pre = self._predict(dataSet) real = dataSet[:,-1] residual = real - pre return np.sum(residual*residual) def _rsq(self,dataSet): # &#x8BA1;&#x7B97;&#x51B3;&#x5B9A;&#x7CFB;&#x6570; R pre = self._predict(dataSet) real = dataSet[:,-1] _mean = np.mean(real) residual = real-pre res = real - _mean return 1 - (np.sum(residual*residual))/(np.sum(res*res)) def _ars(self,dataSet): # &#x6821;&#x6B63;&#x51B3;&#x5B9A;&#x7CFB;&#x6570; rsq = self._rsq(dataSet) n = dataSet.shape[0] # &#x6837;&#x672C;&#x4E2A;&#x6570; p = dataSet.shape[1]-1 # &#x7279;&#x5F81;&#x4E2A;&#x6570; return 1-((1-rsq)*(n-1))/(n-p-1) def evaluate(self,dataSet,etype = &apos;sse&apos;): if etype == &apos;sse&apos;: return self._sse(dataSet) if etype == &apos;rsq&apos;: return self._rsq(dataSet) if etype == &apos;ars&apos;: return self._ars(dataSet) def train_and_evaluate(self,train_dataSet,test_dataSet,dim=2,maxIter = 1000,minErr = 0.01): # self.train(train_dataSet,maxIter = maxIter,minErr = minErr) pre_data = self._predict(train_dataSet) sse = self.evaluate(train_dataSet,&apos;sse&apos;) rsq = self.evaluate(train_dataSet,&apos;rsq&apos;) ars = self.evaluate(train_dataSet,&apos;ars&apos;) print(&apos;train sse:&apos;,sse) print(&apos;train rsq:&apos;,rsq) print(&apos;train ars:&apos;,ars) test_pre_data = self._predict(test_dataSet) test_sse = self.evaluate(test_dataSet,&apos;sse&apos;) test_rsq = self.evaluate(test_dataSet,&apos;rsq&apos;) test_ars = self.evaluate(test_dataSet,&apos;ars&apos;) print(&apos;test sse:&apos;,test_sse) print(&apos;test rsq:&apos;,test_rsq) print(&apos;test ars:&apos;,test_ars) plt.figure() if dim == 2: p1 = plt.scatter(train_dataSet[:,0], train_dataSet[:,-1], color=&apos;b&apos;) p2 = plt.scatter(train_dataSet[:,0], pre_data, color=&apos;c&apos;) p3 = plt.scatter(test_dataSet[:,0], test_pre_data, color=&apos;r&apos;) plt.legend([p1, p2,p3], [&apos;train_real&apos;, &apos;train_pred&apos;,&apos;test_pred&apos;]) elif dim == 3: #&#x5B9A;&#x4E49;&#x5750;&#x6807;&#x8F74; from mpl_toolkits.mplot3d import Axes3D ax1 = plt.axes(projection=&apos;3d&apos;) p1 = ax1.scatter3D(train_dataSet[:,0],train_dataSet[:,1],train_dataSet[:,-1], cmap=&apos;blue&apos;) #&#x7ED8;&#x5236;&#x8BAD;&#x7EC3;&#x6837;&#x672C; p2 = ax1.scatter3D(train_dataSet[:,0],train_dataSet[:,1],pre_data, cmap=&apos;blue&apos;) #&#x7ED8;&#x5236;&#x8BAD;&#x7EC3;&#x6837;&#x672C; p3 = ax1.scatter3D(test_dataSet[:,0],test_dataSet[:,1],test_pre_data, cmap=&apos;gray&apos;) #&#x7ED8;&#x5236;&#x6563;&#x70B9;&#x56FE; plt.legend([p1,p2,p3],[&apos;train_real&apos;,&apos;train_pred&apos;,&apos;test_pred&apos;]) # &#x7ED8;&#x5236;&#x7684;&#x989C;&#x8272;https://matplotlib.org/gallery/color/named_colors.html#sphx-glr-gallery-color-named-colors-py else: print(&quot;Only supports 2D and 3D&quot;) plt.figure() ax1 = plt.axes() if test_sse &gt; 5*sse: evaluation = [rsq,ars] test_evaluation = [test_rsq,test_ars] tick_label = [&apos;rsq&apos;,&apos;ars&apos;] else: evaluation = [sse,rsq,ars] test_evaluation = [test_sse,test_rsq,test_ars] tick_label = [&apos;sse&apos;,&apos;rsq&apos;,&apos;ars&apos;] start = 0 margin= 2 width = 1 pos_x = [] for i in range(len(evaluation)): pos_x.append(i*(2*width+margin)) plt.bar(pos_x,evaluation,width=width,label = &quot;train evaluate&quot; ) for i in range(len(evaluation)): pos_x[i]+=width plt.bar(pos_x,test_evaluation,width=width,label = &quot;test evaluate&quot;,tick_label=tick_label) plt.show()if __name__ == &quot;__main__&quot;: # boost = BoostTree() # X_data_raw = 10*np.random.random(100) -5 # X_data = np.transpose([X_data_raw]) # y_data = np.sin(X_data_raw) # dataSet = np.hstack((X_data,y_data[:,np.newaxis])) # test_X_data_raw = np.linspace(-5, 5, 1000) # test_X_data = np.transpose([test_X_data_raw]) # test_y_data = np.sin(test_X_data_raw) # test_dataSet = np.hstack((test_X_data,test_y_data[:,np.newaxis])) # boost.train_and_evaluate(dataSet,test_dataSet,maxIter = 1000,minErr = 0.1) #&#x5B9A;&#x4E49;&#x5750;&#x6807;&#x8F74; z = np.linspace(0,13,1000) x = 5*np.sin(z) y = 5*np.cos(z) zd = 13*np.random.random(300) xd = 5*np.sin(zd) yd = 5*np.cos(zd) boost = BoostTree() dataSet = np.hstack((xd[:,np.newaxis],yd[:,np.newaxis],zd[:,np.newaxis])) train_pre_data = boost._predict(dataSet) # &#x6D4B;&#x8BD5;&#x96C6; test_zd = 13*np.random.random(100) test_xd = 5*np.sin(test_zd) test_yd = 5*np.cos(test_zd) test_dataSet = np.hstack((test_xd[:,np.newaxis],test_yd[:,np.newaxis],test_zd[:,np.newaxis])) test_pre_data = boost._predict(test_dataSet) boost.train_and_evaluate(dataSet,test_dataSet,maxIter = 100,minErr = 0.01,dim=3) &#x6548;&#x679C;&#x56FE; &#x8BC4;&#x4F30;]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>boost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[adaboost]]></title>
    <url>%2Fblog%2F2019%2F08%2F13%2F%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2Fadaboost%2Fadaboost%2F</url>
    <content type="text"><![CDATA[&#x4E2A;&#x4EBA;&#x7406;&#x89E3;adaboost&#x662F;&#x5C06;&#x591A;&#x4E2A;&#x5F31;&#x5206;&#x7C7B;&#x5668;&#x7684;&#x7ED3;&#x679C;&#x901A;&#x8FC7;&#x4E00;&#x4E2A;alpha&#x7CFB;&#x6570;&#x7EBF;&#x6027;&#x7EC4;&#x5408;&#x5F97;&#x5230;&#x6700;&#x7EC8;&#x7684;&#x9884;&#x6D4B;&#x7ED3;&#x679C;&#xFF0C;&#x6BCF;&#x4E2A;&#x5F31;&#x5206;&#x7C7B;&#x5668;&#x5728;&#x8BA1;&#x7B97;&#x8BEF;&#x5DEE;&#x65F6;&#xFF0C;&#x662F;&#x6839;&#x636E;&#x6837;&#x4F8B;&#x7684;&#x6743;&#x91CD;&#x5F97;&#x5230;&#x7684;&#x52A0;&#x6743;&#x8BEF;&#x5DEE;&#xFF0C;&#x800C;&#x4E0B;&#x4E00;&#x6B21;&#x6743;&#x91CD;&#x7684;&#x66F4;&#x65B0;&#x4E0E;&#x8BE5;&#x5206;&#x7C7B;&#x5668;&#x7684;&#x8BEF;&#x5DEE;&#x6709;&#x5173;&#x3002; &#x6BCF;&#x4E2A;&#x5207;&#x5206;&#x4F1A;&#x6709;&#x4E00;&#x7EC4;&#x9884;&#x6D4B;&#x7ED3;&#x679C; P(&#x6837;&#x672C;&#x6570;&#x91CF;&#x7684;&#x5217;&#x5411;&#x91CF;)&#x7684;&#x6B63;&#x8BEF;Q(&#x548C;P&#x4E00;&#x6837;),&#x9884;&#x6D4B;&#x6B63;&#x786E;&#x7684;&#x4E3A;0 &#x9519;&#x8BEF;&#x7684;&#x4E3A;1&#xFF0C;&#x603B;&#x8BEF;&#x5DEE; = sum(W*Q) W &#x4E3A;&#x4E0A;&#x4E00;&#x8F6E;&#x7684;&#x6BCF;&#x4E2A;&#x6837;&#x672C;&#x7684;&#x6743;&#x91CD;,&#x4E0A;&#x4E00;&#x6B65;&#x7684;&#x8D1F;&#x4F8B;&#x6743;&#x503C;&#x4F1A;&#x5F88;&#x5927;&#xFF0C;&#x5982;&#x679C;&#x8FD9;&#x91CC;&#x4E00;&#x8F6E;&#x8FD8;&#x662F;&#x8D1F;&#x4F8B;,&#x5219;&#x8BE5;&#x4F8B;&#x4EA7;&#x751F;&#x7684;errloss&#x8D21;&#x732E;&#x4F1A;&#x5F88;&#x5927;&#xFF0C;&#x53CD;&#x4E4B;&#x5219;errloss&#x8D21;&#x732E;&#x4F1A;&#x53D8;&#x4E3A;0&#x56E0;&#x4E3A;Q(&#x6B63;&#x4F8B;) = 0,&#x8FD9;&#x6837;&#x4F1A;&#x4EA7;&#x751F;&#x4E00;&#x4E2A;&#x8D1F;&#x53CD;&#x9988;&#xFF0C;&#x8BA9;&#x8D1F;&#x4F8B;&#x4E0D;&#x65AD;&#x7684;&#x8BAD;&#x7EC3;&#x3002; &#x4E00;&#x4E2A;&#x5207;&#x5206;&#x7684;&#x603B;&#x9519;&#x8BEF;&#x7387;&#x662F;&#x52A0;&#x6743;&#x9519;&#x8BEF;&#x7387; E = sum(W*Q) &#x8BA1;&#x7B97;alpha = 1/2(log((1-e)/e)) &#x8BA1;&#x7B97;&#x6837;&#x4F8B;&#x7684;&#x6743;&#x91CD;W = W* exp(-alpha*T)/sum(W) &#x5176;&#x4E2D; &#x5BF9;&#x8BAD;&#x7EC3;&#x6B63;&#x786E;&#x7684;&#x6837;&#x672C; T=1 &#x9519;&#x8BEF;&#x7684;&#x6837;&#x672C;&#x662F;-1;sum(W)&#x8868;&#x793A;&#x4E0A;&#x4E00;&#x8F6E;&#x7684;&#x6743;&#x91CD;&#x4E4B;&#x548C; &#x6B63;&#x4F8B;&#x6743;&#x503C;&#x5927;&#xFF0C;&#x8D1F;&#x4F8B;&#x6743;&#x503C;&#x5C0F;(&#x6837;&#x4F8B;&#x7684;&#x6743;&#x91CD;&#xFF0C;&#x53EA;&#x770B;&#x5206;&#x5B50;&#x90E8;&#x5206;&#xFF0C;&#x968F;&#x7740;alpha&#x53D8;&#x5316;&#xFF0C;&#x6B63;&#x4F8B;&#x5728;0-1&#x9012;&#x51CF;&#xFF0C;&#x8D1F;&#x4F8B;&gt;1&#x9012;&#x589E;)&#x7684;&#x7D2F;&#x52A0;&#x7ED3;&#x679C;&#x7684;&#x9519;&#x8BEF;&#x7387; &#x5355;&#x4E2A;&#x5206;&#x7C7B;&#x5668;&#x7684;&#x7ED3;&#x679C;P = alpha*P &#x6700;&#x7EC8;&#x7684;&#x9884;&#x6D4B;&#x7ED3;&#x679C;&#x4E3A; P = alpha1*p1 + alpha2*p2 +alpha3*p3 +&#x2026;+alpha_n*pn,&#x518D;&#x5BF9;P&#x53D6;&#x7B26;&#x53F7;&#x5C31;&#x5F97;&#x9884;&#x6D4B;&#x7ED3;&#x679C;P = sign(P) &#x4EE3;&#x7801; &#x52A0;&#x8F7D;&#x6570;&#x636E;&#x96C6;12345678910111213141516import numpy as np def loadData(filepath,split_char = &apos;\t&apos;,floats = False): # &#x52A0;&#x8F7D;&#x6570;&#x636E;&#x96C6; dataSet = [] with open(filepath) as file: for line in file.readlines(): currline = line.strip().split(split_char)# &#x53BB;&#x524D;&#x540E;&#x7A7A;&#x683C; &#x8F6C;&#x6570;&#x7EC4; fltLine = [] for i in currline: if floats: fltLine.append(float(i)) else: fltLine.append(i) dataSet.append(fltLine) return dataSet &#x6839;&#x636E;&#x5207;&#x5206;&#x70B9;&#x5F97;&#x5230;&#x9884;&#x6D4B;&#x7684;&#x7ED3;&#x679C;12345678910def stumpClassify(dataSet,thresh,index,value,ctype =0): # &#x9884;&#x6D4B; P = np.ones((dataSet.shape[0],1)) # &#x5C0F;&#x4E8E;value&#x7684;&#x9884;&#x6D4B;&#x4E3A;-1&#xFF0C;&#x5927;&#x4E8E;&#x7B49;&#x4E8E;&#x7684;&#x9884;&#x6D4B;&#x4E3A;1 if thresh == &apos;&lt;&apos;: P[dataSet[:,index] &lt; value] = -1 else: P[dataSet[:,index] &gt;= value] = -1 return P &#x57FA;&#x5206;&#x7C7B;&#x5668;&#xFF0C;&#x635F;&#x5931;&#x662F;&#x6837;&#x672C;&#x52A0;&#x6743;&#x635F;&#x5931;123456789101112131415161718192021222324252627282930313233343536def adaBaseClassifier(dataSet,W,labelIndex=-1,ctype = 0): # &#x57FA;&#x672C;&#x5206;&#x7C7B;&#x5668; - &#x4E8C;&#x5206;&#x7C7B; # dataSet &#x6570;&#x636E;&#x96C6; &#x5305;&#x542B;&#x6570;&#x636E;&#x548C;&#x6807;&#x7B7E; np.array # W &#x6BCF;&#x884C;&#x6570;&#x636E;&#x7684;&#x6743;&#x91CD;&#xFF0C;&#x521D;&#x59CB;&#x4E3A; 1/len(dataSet) &#x5217;&#x5411;&#x91CF; np.array # labelIndex &#x6807;&#x7B7E;&#x7684;&#x4F4D;&#x7F6E;&#xFF0C;&#x4E00;&#x822C;&#x4E3A;&#x6700;&#x540E;&#x4E00;&#x4F4D; # ctype = 0 &#xFF1A;&#x6570;&#x503C;&#x7C7B;&#x578B; &#x5206;&#x7C7B;&#x5C06;&#x6839;&#x636E;&#x5C0F;&#x4E8E;&#x548C;&#x5927;&#x4E8E;&#x7B49;&#x4E8E;&#x8FDB;&#x884C;&#x5212;&#x5206; # ctype = 1 &#xFF1A;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#xFF0C;&#x5B57;&#x7B26;&#x4E32;&#x548C;&#x6570;&#x5B57;&#x5747;&#x53EF; &#x5206;&#x7C7B;&#x5C06;&#x6839;&#x636E;&#x7B49;&#x4E8E;&#x4E0E;&#x4E0D;&#x7B49;&#x4E8E;&#x8FDB;&#x884C;&#x5212;&#x5206; &#x672A;&#x5B9E;&#x73B0; m,n = np.shape(dataSet) # m &#x6837;&#x672C;&#x7684;&#x6570;&#x91CF; n &#x7279;&#x5F81;&#x7EF4;&#x5EA6;+1 &#xFF08;1 &#x662F;&#x6807;&#x7B7E;&#xFF09; # print(&apos;W:&apos;,W) # &#x904D;&#x5386;&#x7279;&#x5F81; minLoss = np.inf bestIndex = 0 bestVal = 0 bestP = [] bestthresh = &apos;&apos; for index in range(n-2): # &#x904D;&#x5386;&#x7279;&#x5F81;&#x5BF9;&#x5E94;&#x7684;&#x503C; for value in dataSet[:,index]: # &#x6837;&#x672C;&#x6570;&#x91CF;&#x7684;&#x5217;&#x5411;&#x91CF;,&#x5B58;&#x50A8;&#x9884;&#x6D4B;&#x7ED3;&#x679C; for thresh in [&apos;&lt;&apos;,&apos;&gt;=&apos;]: P = stumpClassify(dataSet,thresh,index,value,ctype =0) Q = np.ones(P.shape) # print(&apos;P:\n&apos;,P) Q[P == dataSet[:,labelIndex][:,np.newaxis]] = 0 # print(&apos;Q:\n&apos;,Q) # print(W*Q) totalLoss = np.sum(W*Q) # print(&apos;loss is &apos;,totalLoss) if totalLoss &lt; minLoss: minLoss = totalLoss bestIndex = index bestVal = value bestP = P bestthresh = thresh # print(&quot;minLoss,bestIndex,thresh,bestVal,bestP:\n&quot;,minLoss,bestIndex,bestthresh,bestVal,bestP) return minLoss,bestIndex,bestthresh,bestVal,bestP adaBoost &#x4E3B;&#x4F53;&#x90E8;&#x5206;123456789101112131415161718192021222324252627282930313233def adaBoost(dataSet,maxIter=20,minErr = 0,ctype=0,labelIndex = -1,baseClassifier = adaBaseClassifier): M = dataSet.shape[0] # &#x6837;&#x672C;&#x6570;&#x91CF; W = np.array([1/M]*M)# &#x6BCF;&#x4E2A;&#x6837;&#x672C;&#x5BF9;&#x635F;&#x5931;&#x7684;&#x6743;&#x91CD;&#xFF0C;&#x521D;&#x59CB;&#x90FD;&#x4E00;&#x6837; W = W[:,np.newaxis] # print(&apos;W:\n&apos;,W) classifiers = [] predictVal = np.zeros((M,1)) for i in range(maxIter): minLoss,bestIndex,thresh,bestVal,bestP = baseClassifier(dataSet,W) # print(&apos;minloss:\n&apos;,minLoss) alpha = 1/2*(np.log((1-minLoss)/(minLoss+1e-10))) if alpha == np.inf or alpha == -np.inf: alpha = 10 # print(&apos;alpha:\n&apos;,alpha) # print(&apos;bestP:\n&apos;,bestP) # print(&apos;label:\n&apos;,dataSet[:,labelIndex]) W = W*np.exp(-1.0*alpha*bestP*dataSet[:,labelIndex][:,np.newaxis])/np.sum(W) # print(&quot;W:&quot;,W.T) classifier = {} classifier[&apos;index&apos;] = bestIndex classifier[&apos;value&apos;] = bestVal classifier[&apos;thresh&apos;] = thresh classifier[&apos;alpha&apos;] = alpha classifiers.append(classifier) predictVal +=alpha * bestP # print(predictVal) err = np.sign(predictVal)!=dataSet[:,labelIndex][:,np.newaxis] err = err.sum()/M print(&quot;iter is {},err is{} &quot;.format(i,err)) if err&lt;=minErr: break # print(&quot;train pre is \n&quot;,predictVal) return classifiers &#x5F97;&#x5230;&#x5206;&#x7C7B;&#x5668;&#x540E;&#x9884;&#x6D4B;&#x7ED3;&#x679C;1234567891011121314151617def adaboostPredict(dataSet_test,classifiers): print(&quot;============================&quot;) M = dataSet_test.shape[0] predictVal = np.zeros((M,1)) for classifier in classifiers: P = stumpClassify(dataSet_test,classifier[&apos;thresh&apos;],classifier[&apos;index&apos;],classifier[&apos;value&apos;],ctype =0) # print(&quot;thresh:\n&quot;,classifier[&apos;thresh&apos;]) # print(&quot;index:\n&quot;,classifier[&apos;index&apos;]) # print(&quot;alpha:\n&quot;,classifier[&apos;alpha&apos;]) # print(&quot;value:\n&quot;,classifier[&apos;value&apos;]) # print(&quot;P:\n&quot;,P) predictVal +=classifier[&apos;alpha&apos;] * P # print(&quot;predictVal \n&quot;,predictVal) err = np.sign(predictVal)!=dataSet[:,-1][:,np.newaxis] err = err.sum()/M print(&quot;predict err is :&quot;,err) return np.sign(predictVal) &#x6D4B;&#x8BD5;&#x6837;&#x4F8B;1234567891011121314151617181920212223242526272829303132333435def simple_dataSet(simple = 0): if simple == 0: data = [ [ 1.0 ,2.1,1.0], [ 2.0 ,1.1,1.0], [ 1.3 ,1.0,-1.0], [ 1.0 ,1.0,-1.0], [ 2.0 ,1.0,1.0] ] elif simple ==1: data = [ [1,0,1], [2,1,1], [3,2,1], [4,3,-1], [5,4,-1], [6,5,-1], [7,6,1], [8,7,1], [9,8,1], [10,9,-1], ] else: pass return np.array(data)if __name__ == &quot;__main__&quot;: # dataSet = simple_dataSet(1) # classifliers = adaBoost(dataSet) # pre = adaboostPredict(dataSet,classifliers) dataSet = loadData(&apos;horseColicTraining2.txt&apos;,split_char = &apos;\t&apos;,floats = True) dataSet = np.array(dataSet) classifliers = adaBoost(dataSet,maxIter=200) pre = adaboostPredict(dataSet,classifliers)]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>adaboost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习知识点]]></title>
    <url>%2Fblog%2F2019%2F08%2F13%2F%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[&#x6301;&#x7EED;&#x66F4;&#x65B0; &#x51B3;&#x7B56;&#x6811; ID3 C4.5 CART cart &#x96C6;&#x6210;&#x5B66;&#x4E60; &#x968F;&#x673A;&#x68EE;&#x6797; adaboost adaboost gdbt bagging LRsvmLSTM LSTM &#x6A21;&#x5F0F;&#x8BC6;&#x522B;(https://blog.csdn.net/qq_28620327/article/details/82345511) K-Nearest Neighbor Bayes Classifier Principle Component Analysis(PCA) Linear Discriminant Analysis(LDA) Non-negative Matrix Factorization (http://chnfyn.blog.163.com/blog/static/26954632200751625243295/) Gaussian Mixture Model &#x95EE;&#x9898;&#x795E;&#x7ECF;&#x7F51;&#x7EDC;&#x5982;&#x4F55;&#x5DE5;&#x4F5C;SVM&#x7684;&#x539F;&#x7406;&#x53CA;&#x516C;&#x5F0F;&#x63A8;&#x5BFC;&#x6734;&#x7D20;&#x8D1D;&#x53F6;&#x65AF;&#x7684;&#x516C;&#x5F0F;Bagging &#x548C; Boosting&#x7684;&#x533A;&#x522B;GBDT&#x7684;&#x53C2;&#x6570;&#x600E;&#x4E48;&#x8C03;&#x805A;&#x7C7B;&#x8FC7;&#x7A0B;&#x504F;&#x5DEE;&#x548C;&#x65B9;&#x5DEE;&#x662F;&#x4EC0;&#x4E48;&#xFF0C;&#x9AD8;&#x504F;&#x5DEE;&#x548C;&#x9AD8;&#x65B9;&#x5DEE;&#x8BF4;&#x660E;&#x4E86;&#x4EC0;&#x4E48;&#x600E;&#x4E48;&#x7406;&#x89E3;&#x635F;&#x5931;&#x51FD;&#x6570;&#xFF0C;SVM&#x7684;&#x635F;&#x5931;&#x51FD;&#x6570;&#x662F;&#x4EC0;&#x4E48;&#xFF0C;&#x5199;&#x51FA;&#x516C;&#x5F0F;&#x8FC7;&#x62DF;&#x5408;&#x600E;&#x4E48;&#x89E3;&#x51B3;&#xFF0C;L1&#x548C;L2&#x6B63;&#x5219;&#x5316;&#x6709;&#x4EC0;&#x4E48;&#x533A;&#x522B;&#x4E3A;&#x4EC0;&#x4E48;&#x7528;&#x6700;&#x5C0F;&#x4E8C;&#x4E58;&#x800C;&#x4E0D;&#x662F;&#x6700;&#x5C0F;&#x56DB;&#x4E58;GB&#x548C;&#x725B;&#x987F;&#x6CD5;&#x7684;&#x533A;&#x522B;&#xFF0C;&#x5B83;&#x4EEC;&#x548C;&#x6CF0;&#x52D2;&#x516C;&#x5F0F;&#x7684;&#x5173;&#x7CFB;]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python [::2] 什么意思]]></title>
    <url>%2Fblog%2F2019%2F08%2F13%2Fpython%2Fpython%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[&#x505A;&#x4E2A;&#x8BB0;&#x5F55; list[start:end:step] start:&#x8D77;&#x59CB;&#x4F4D;&#x7F6E; end:&#x7ED3;&#x675F;&#x4F4D;&#x7F6E; step:&#x6B65;&#x957F; range(100)[20:30:2] [20, 22, 24, 26, 28] &#x6765;&#x6E90;]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python 基本语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python * dot multiply]]></title>
    <url>%2Fblog%2F2019%2F08%2F13%2Fpython%2Fpython-numpy%E7%9A%84%20%E6%98%9F%20multiply%20dot%2F</url>
    <content type="text"><![CDATA[&#x7ED3;&#x8BBA;&#xFF1A;python 3&#x5BF9;&#x6570;&#x7EC4;array &#x548C;multiply &#x4E00;&#x6837;,&#x5BF9;&#x5E94;&#x4F4D;&#x7F6E;&#x76F8;&#x4E58;dot(A,B) A&#x7684;m&#x884C; &#x4E58;&#x4EE5;B&#x7684;n&#x5217;&#x4E4B;&#x548C;&#x4E3A;&#x7ED3;&#x679C;&#x7684;m&#x884C;n&#x5217;&#x7684;&#x503C;&#x3002; &#x5BF9;&#x77E9;&#x9635;mat &#x548C;dot&#x4E00;&#x6837; A&#x7684;m&#x884C; &#x4E58;&#x4EE5;B&#x7684;n&#x5217;&#x4E4B;&#x548C;&#x4E3A;&#x7ED3;&#x679C;&#x7684;m&#x884C;n&#x5217;&#x7684;&#x503C;&#x3002;mutiply &#x5BF9;&#x5E94;&#x4F4D;&#x7F6E;&#x76F8;&#x4E58;1234567891011121314151617181920import numpy as np if __name__ == &quot;__main__&quot;: A = np.array([[1,2],[3,4]]) B = np.array([[0,1],[2,3]]) print(&apos;A:\n&apos;,A) print(&apos;B:\n&apos;,B) print(&quot;A*B:\n&quot;,A*B) print(&quot;multiply(A,B):\n&quot;,np.multiply(A,B)) print(&quot;A.T*B:\n&quot;,A.T*B) print(&quot;dot(A,B):\n&quot;,np.dot(A,B)) print(A&lt;B) C = np.mat([1,2,3,4]) D = np.mat([1,2,3,4]) print(&apos;C:\n&apos;,C) print(&apos;D:\n&apos;,D) print(&quot;multiply(C,D):\n&quot;,np.multiply(C,D)) print(&quot;C*D.T:\n&quot;,C*D.T) print(&quot;np.dot(C,D.T)\n&quot;,np.dot(C,D.T)) &#x7ED3;&#x679C;12345678910111213141516171819202122232425262728293031A: [[1 2] [3 4]]B: [[0 1] [2 3]]A*B: [[ 0 2] [ 6 12]]multiply(A,B): [[ 0 2] [ 6 12]]A.T*B: [[ 0 3] [ 4 12]]dot(A,B): [[ 4 7] [ 8 15]][[False False] [False False]]C: [[1 2 3 4]]D: [[1 2 3 4]]multiply(C,D): [[ 1 4 9 16]]C*D.T: [[30]]np.dot(C,D.T) [[30]][Finished in 0.4s]]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python 基本语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础练习之平衡树]]></title>
    <url>%2Fblog%2F2019%2F05%2F02%2F%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%2F%E6%A0%91%2F%E5%B9%B3%E8%A1%A1%E6%A0%91%2F%E5%B9%B3%E8%A1%A1%E6%A0%91%2F</url>
    <content type="text"><![CDATA[&#x4E2A;&#x4EBA;&#x7406;&#x89E3;AVL tree (named after inventors Adelson-Velsky and Landis) is a self-balancing binary search tree (https://en.wikipedia.org/wiki/AVL_tree)&#x81EA;&#x5E73;&#x8861;&#x4E8C;&#x53C9;&#x641C;&#x7D22;&#x6811;AVL,&#x5728;&#x4E8C;&#x53C9;&#x641C;&#x7D22;&#x6811;&#x7684;&#x57FA;&#x7840;&#x4E0A;&#x52A0;&#x4E86;&#x4E2A;&#x9650;&#x5236;&#x6761;&#x4EF6;&#xFF0C;&#x6240;&#x6709;&#x5DE6;&#x5B50;&#x6811;&#x4E0E;&#x53F3;&#x5B50;&#x6811;&#x7684;&#x9AD8;&#x5EA6;&#x5DEE;&#x4E0D;&#x8D85;&#x8FC7;1,&#x5176;&#x4ED6;&#x548C;&#x4E8C;&#x53C9;&#x641C;&#x7D22;&#x6570;&#x4E00;&#x6837;&#x3002; &#x5E73;&#x8861;&#x4E8C;&#x53C9;&#x6811;&#x7EC6;&#x8282;&#x8282;&#x70B9;&#x5B9A;&#x4E49;&#x8282;&#x70B9;&#x4E2D;&#x9664;&#x4E86;&#x5305;&#x542B;&#x6570;&#x636E;&#xFF0C;&#x5DE6;&#x8282;&#x70B9;&#xFF0C;&#x53F3;&#x8282;&#x70B9;&#x5916;&#xFF0C;&#x8FD8;&#x5305;&#x542B;&#x4E86;&#x5F53;&#x524D;&#x8282;&#x70B9;&#x4F5C;&#x4E3A;&#x6839;&#x65F6;&#x7684;&#x9AD8;&#x5EA6;&#x3002;&#x65B0;&#x5EFA;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x65F6;&#x4E00;&#x5B9A;&#x8981;&#x5C06;&#x5DE6;&#x8282;&#x70B9;&#x548C;&#x53F3;&#x8282;&#x70B9;&#x7F6E;&#x4E3A;NULL,&#x5426;&#x5219;&#x53EF;&#x80FD;&#x51FA;&#x73B0;&#x6307;&#x5411;&#x4E0D;&#x786E;&#x5B9A;&#x4F4D;&#x7F6E;&#x51FA;&#x73B0;&#x9519;&#x8BEF;&#x3002;12345678typedef int T;struct TreeNode{ T val; //&#x5173;&#x952E;&#x5B57; int height;//&#x5F53;&#x524D;&#x8282;&#x70B9;&#x7684;&#x9AD8;&#x5EA6; TreeNode * left; TreeNode * right; TreeNode(T v):val(v),left(NULL),right(NULL),height(0){}}; &#x6811;&#x7684;&#x5B9A;&#x4E49;&#x5C06;AVL&#x5B9A;&#x4E49;&#x4E3A;class12345678910111213141516171819202122232425262728293031class AVL{private: TreeNode * root; TreeNode * LL(TreeNode * node);//&#x5DE6;&#x5DE6;&#x65CB; TreeNode * RR(TreeNode * node);//&#x53F3;&#x53F3;&#x65CB; TreeNode * LR(TreeNode * node);//&#x5DE6;&#x53F3;&#x65CB; TreeNode * RL(TreeNode * node);//&#x53F3;&#x5DE6;&#x65CB; int tree_height(TreeNode * node);//&#x6811;&#x7684;&#x9AD8;&#x5EA6; TreeNode * insert(TreeNode * node,T val);//&#x63D2;&#x5165;&#x8282;&#x70B9; TreeNode * remove(TreeNode * root,TreeNode * node);//&#x5220;&#x9664;&#x8282;&#x70B9; TreeNode * search(TreeNode * root,T val);//&#x641C;&#x7D22; void _pre_order(TreeNode*node);//&#x5148;&#x5E8F;&#x904D;&#x5386; void _in_order(TreeNode*node);//&#x4E2D;&#x5E8F;&#x904D;&#x5386; void _post_order(TreeNode*node);//&#x540E;&#x5E8F;&#x904D;&#x5386; TreeNode* _min_node(TreeNode*);//&#x6700;&#x5C0F;&#x8282;&#x70B9; TreeNode* _max_node(TreeNode*);//&#x6700;&#x5927;&#x8282;&#x70B9; void _del(TreeNode * root);//&#x5220;&#x9664;&#x5168;&#x90E8;&#x6811;&#x7684;&#x7ED3;&#x6784;&#xFF0C;&#x6E05;&#x9664;&#x7A7A;&#x95F4;public: AVL(){root = NULL;} ~AVL(){_del(root);} void destroy(){_del(root);root=NULL;} int tree_height(); int insert(T val); int remove(T val); void pre_order(); void in_order(); void post_order(); TreeNode * search(T val);}; &#x6DFB;&#x52A0;&#x8282;&#x70B9;&#x5728;&#x4E8C;&#x53C9;&#x641C;&#x7D22;&#x6811;&#x7684;&#x57FA;&#x7840;&#x4E0A;&#x6DFB;&#x52A0;&#x540E;&#xFF0C;&#x5224;&#x65AD;&#x662F;&#x5426;&#x6EE1;&#x8DB3;&#x5E73;&#x8861;&#xFF0C;&#x4E0D;&#x6EE1;&#x8DB3;&#x5C31;&#x8C03;&#x6574;&#x3002;&#x8C03;&#x6574;&#x7684;&#x8FC7;&#x7A0B;&#x4E3B;&#x8981;&#x662F;4&#x79CD;&#x65CB;&#x8F6C;&#x3002; LL-&#x5DE6;&#x5DE6;&#x65CB;&#x5F53;&#x524D;&#x6839;&#x8282;&#x70B9;&#x7684;&#x5DE6;&#x5B50;&#x6811; &#x7684; &#x5DE6;&#x5B50;&#x6811; &#x8FD8;&#x6709;&#x5B50;&#x6811;&#xFF0C;&#x800C;&#x6839;&#x8282;&#x70B9;&#x7684;&#x53F3;&#x5B50;&#x6811;&#x65E0;&#x5B50;&#x6811;&#xFF0C;&#x9700;&#x8981;&#x8FDB;&#x884C;&#x5DE6;&#x5DE6;&#x65CB;LL&#x3002;&#x628A;k1&#x7684;&#x53F3;&#x8282;&#x70B9;y&#x53D8;&#x4E3A;k2&#x5DE6;&#x5B50;&#x6811;&#xFF0C;&#x6839;&#x8282;&#x70B9;k2&#x53D8;&#x4E3A;&#x5DE6;&#x5B50;&#x6811;k1&#x7684;&#x53F3;&#x5B50;&#x6811;,k1&#x53D8;&#x4E3A;&#x6839;&#x8282;&#x70B9;&#x3002;&#x66F4;&#x65B0;&#x6811;&#x7684;&#x9AD8;&#x5EA6;&#x3002;1234567891011121314151617TreeNode* AVL::LL(TreeNode * node){ // k2 k1 // / \ / \ // k1 z x k2 // / \ =&gt; / / \ // x y T y z // / // T TreeNode * k2 = node; TreeNode * k1 = k2-&gt;left; k2-&gt;left = k1-&gt;right; k1-&gt;right = k2; k2-&gt;height = MAX( tree_height(k2-&gt;left),tree_height(k2-&gt;right)) + 1; k1-&gt;height = MAX( tree_height(k1-&gt;left),k2-&gt;height) + 1; return k1;} RR&#x5F53;&#x524D;&#x6839;&#x8282;&#x70B9;&#x7684;&#x53F3;&#x5B50;&#x6811; &#x7684; &#x53F3;&#x5B50;&#x6811; &#x8FD8;&#x6709;&#x5B50;&#x6811;&#xFF0C;&#x800C;&#x6839;&#x8282;&#x70B9;&#x7684;&#x5DE6;&#x5B50;&#x6811;&#x65E0;&#x5B50;&#x6811;&#xFF0C;&#x9700;&#x8981;&#x8FDB;&#x884C;&#x53F3;&#x53F3;&#x65CB;RR&#x3002;&#x628A;k2&#x7684;&#x5DE6;&#x8282;&#x70B9;y&#x53D8;&#x4E3A;k1&#x53F3;&#x5B50;&#x6811;&#xFF0C;&#x6839;&#x8282;&#x70B9;k1&#x53D8;&#x4E3A;&#x53F3;&#x5B50;&#x6811;k2&#x7684;&#x5DE6;&#x5B50;&#x6811;,k2&#x53D8;&#x4E3A;&#x6839;&#x8282;&#x70B9;&#x3002;&#x66F4;&#x65B0;&#x6811;&#x7684;&#x9AD8;&#x5EA6;&#x3002;1234567891011121314151617TreeNode* AVL::RR(TreeNode * node){ // k1 k2 // / \ / \ // x k2 k1 z // / \ =&gt; / \ \ // y z x y T // \ // T TreeNode * k1 = node; TreeNode * k2 = k1-&gt;right; k1-&gt;right = k2-&gt;left; k2-&gt;left = k1; k1-&gt;height = MAX( tree_height(k1-&gt;left),tree_height(k1-&gt;right)) + 1; k2-&gt;height = MAX( tree_height(k2-&gt;right),k1-&gt;height) + 1; return k2;} LR&#x5F53;&#x524D;&#x6839;&#x8282;&#x70B9;&#x7684;&#x5DE6;&#x5B50;&#x6811; &#x7684; &#x53F3;&#x5B50;&#x6811;&#x8FD8;&#x6709;&#x5B50;&#x6811;&#xFF0C;&#x800C;&#x6839;&#x8282;&#x70B9;&#x7684;&#x53F3;&#x5B50;&#x6811;&#x65E0;&#x5B50;&#x6811;&#x3002;&#x6B64;&#x65F6;&#x9700;&#x8981;&#x5DE6;&#x53F3;&#x65CB;LR&#x3002; &#x5BF9;&#x5DE6;&#x5B50;&#x6811;&#x6267;&#x884C;RR(root-&gt;left)&#x518D;&#x5BF9;&#x5F53;&#x524D;&#x6811;&#x6267;&#x884C;LL(root)12345TreeNode* AVL::LR(TreeNode * node){ // &#x5DE6;&#x5B69;&#x5B50;&#x7684;&#x53F3;&#x5B69;&#x5B50;&#x6709;&#x8282;&#x70B9; node-&gt;left = RR(node-&gt;left); return LL(node);} RL&#x4E0E;LR&#x76F8;&#x53CD;&#x5C31;&#x884C;&#x4E86;&#x3002; &#x5BF9;&#x53F3;&#x5B50;&#x6811;&#x6267;&#x884C;LL(root-&gt;right)&#x518D;&#x5BF9;&#x5F53;&#x524D;&#x6811;&#x6267;&#x884C;LL(root)12345TreeNode* AVL::RL(TreeNode * node){ // &#x53F3;&#x5B69;&#x5B50;&#x7684;&#x5DE6;&#x5B69;&#x5B50;&#x6709;&#x8282;&#x70B9; node-&gt;right = LL(node-&gt;right); return RR(node);} &#x6DFB;&#x52A0;&#x8282;&#x70B9;&#x4EE3;&#x7801;12345678910111213141516171819202122232425262728293031323334353637383940414243TreeNode* AVL::insert(TreeNode * node,T val){ // &#x63D2;&#x5165;&#x6570;&#x636E; if(node == NULL){ node = new TreeNode(val); }else if(val &lt; node-&gt;val){ //&#x63D2;&#x5165;&#x5230;&#x5DE6;&#x5B50;&#x6811; node-&gt;left = insert(node-&gt;left,val); //&#x82E5;&#x5931;&#x53BB;&#x5E73;&#x8861;&#xFF0C;&#x8C03;&#x6574; if(tree_height(node-&gt;left) - tree_height(node-&gt;right)==2){ if(val&lt;node-&gt;left-&gt;val){ // &#x63D2;&#x5165;&#x5230;&#x5DE6;&#x5B50;&#x6811;&#x7684;&#x5DE6;&#x5B50;&#x6811;&#x4E0A;&#x5BFC;&#x81F4;&#x5931;&#x8861;&#xFF0C;&#x6267;&#x884C;LL node = LL(node); }else{ node = LR(node); } } }else if(val&gt;node-&gt;val){ //&#x63D2;&#x5165;&#x5230;&#x53F3;&#x5B50;&#x6811; node-&gt;right = insert(node-&gt;right,val); if(tree_height(node-&gt;right) - tree_height(node-&gt;left)==2){ if(val&gt;node-&gt;right-&gt;val){ node = RR(node); }else{ node = RL(node); } } }else{ // &#x6DFB;&#x52A0;&#x76F8;&#x540C;&#x7684;&#x8282;&#x70B9; // return NULL; cout&lt;&lt;&quot;&#x6DFB;&#x52A0;&#x76F8;&#x540C;&#x7684;&#x8282;&#x70B9;&quot;; } node-&gt;height = MAX( tree_height(node-&gt;left),tree_height(node-&gt;right) ) + 1; return node;}int AVL::insert(T val){ TreeNode*p = insert(root,val); if(p){ this-&gt;root = p; return 0; }else{ return -1; }} &#x5220;&#x9664;&#x8282;&#x70B9;&#x5220;&#x9664;&#x8282;&#x70B9;&#x540E;&#xFF0C;&#x5982;&#x679C;&#x4E0D;&#x5E73;&#x8861;&#x5C31;&#x8FDB;&#x884C;&#x8C03;&#x6574;&#xFF0C;&#x4E5F;&#x662F;&#x4E0A;&#x9762;&#x7684;4&#x4E2D;&#x65CB;&#x8F6C; &#x4EE3;&#x7801;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051TreeNode* AVL::remove(TreeNode * root,TreeNode* node){ if(root == NULL || node == NULL){ return root; } if(node-&gt;val &lt; root-&gt;val){ root-&gt;left = remove(root-&gt;left,node); if(tree_height(root-&gt;right) - tree_height(root-&gt;left) == 2){ if(tree_height(root-&gt;right-&gt;left)&gt;tree_height(root-&gt;right-&gt;right)){ root = RL(root); }else{ root = RR(root); } } }else if(node-&gt;val &gt; root-&gt;val){ root-&gt;right = remove(root-&gt;right,node); if(tree_height(root-&gt;left) - tree_height(root-&gt;right) == 2){ if(tree_height(root-&gt;left-&gt;left)&gt;tree_height(root-&gt;left-&gt;right)){ root = LL(root); }else{ root = LR(root); } } }else{ if(root-&gt;left &amp;&amp; root-&gt;right){ if(tree_height(root-&gt;left) &gt;tree_height(root-&gt;right)){ // &#x5DE6;&#x8FB9;&gt;&#x53F3;&#x8FB9;&#xFF0C;&#x66FF;&#x6362;&#x5DE6;&#x8FB9;&#x7684;&#x6700;&#x5927;&#x7684;&#xFF0C;&#x5220;&#x9664;&#x6700;&#x5927;&#x7684; TreeNode * maxnode = _max_node(root-&gt;left); root-&gt;val = maxnode-&gt;val; root-&gt;left = remove(root-&gt;left,maxnode); }else{ // &#x5DE6;&#x8FB9;&lt;&#x53F3;&#x8FB9;&#xFF0C;&#x66FF;&#x6362;&#x53F3;&#x8FB9;&#x7684;&#x6700;&#x5C0F;&#x7684;&#xFF0C;&#x5220;&#x9664;&#x6700;&#x5C0F;&#x7684; TreeNode * minnode = _min_node(root-&gt;right); root-&gt;val = minnode-&gt;val; root-&gt;right = remove(root-&gt;right,minnode); } }else{ // &#x76F4;&#x63A5;&#x5220;&#x9664; TreeNode * tmp = root; root = root-&gt;left?root-&gt;left:root-&gt;right; delete tmp; } } return root;}int AVL::remove(T val){ TreeNode*node = search(val); remove(this-&gt;root,node); return 0;} &#x6790;&#x6784;&#x53EA;&#x5EFA;&#x7ACB;&#xFF0C;&#x4E0D;&#x91CA;&#x653E;&#x5185;&#x5B58;&#x662F;&#x4F1A;&#x9020;&#x6210;&#x5185;&#x5B58;&#x6CC4;&#x6F0F;&#x7684;&#xFF0C;&#x56E0;&#x6B64;&#x6790;&#x6784;&#x662F;&#x5FC5;&#x4E0D;&#x53EF;&#x5C11;&#x7684;&#x3002;&#x8FD9;&#x91CC;&#x4F7F;&#x7528;&#x540E;&#x5E8F;&#x904D;&#x5386;&#x7684;&#x65B9;&#x5F0F;&#x6790;&#x6784;&#xFF0C;&#x5148;&#x91CA;&#x653E;&#x5DE6;&#x53F3;&#x8282;&#x70B9;&#xFF0C;&#x5728;&#x91CA;&#x653E;&#x6839;&#x8282;&#x70B9;&#x3002;123456789101112void AVL::_del(TreeNode * root){ if(root!=NULL){ if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL){ delete root; return; }else{ _del(root-&gt;left); _del(root-&gt;right); delete root; } }} &#x5B8C;&#x6574;&#x4EE3;&#x7801;&#x53C2;&#x8003;https://en.wikipedia.org/wiki/AVL_treehttp://www.cnblogs.com/skywang12345/p/3577360.html]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>基础练习</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础练习汇总]]></title>
    <url>%2Fblog%2F2019%2F05%2F01%2F%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%2F%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[&#x6570;&#x636E;&#x7ED3;&#x6784;&#x94FE;&#x8868;&#x5355;&#x94FE;&#x8868;&#x5355;&#x94FE;&#x8868; &#x53CC;&#x5411;&#x94FE;&#x8868;&#x6570;&#x7EC4;&#x6808;&#x961F;&#x5217;&#x6811;&#x5B8C;&#x5168;&#x4E8C;&#x53C9;&#x6811;&#x4E8C;&#x53C9;&#x641C;&#x7D22;&#x6811;&#x5E73;&#x8861;&#x4E8C;&#x53C9;&#x6811;&#xFF08;AVL&#xFF09;&#x7EA2;&#x9ED1;&#x6811;&#x5B57;&#x5178;&#x6811;&#x56FE;&#x65E0;&#x5411;&#x56FE;&#x6709;&#x5411;&#x56FE;&#x54C8;&#x5E0C;&#x8868;#2 &#x5E38;&#x7528;&#x7B97;&#x6CD5; #3]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2Fblog%2F2019%2F05%2F01%2F%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%2F%E6%95%B0%E7%BB%84%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2Fblog%2F2019%2F05%2F01%2F%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%2F%E9%93%BE%E8%A1%A8%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[&#x7B80;&#x5355;&#x4ECB;&#x7ECD;&#x94FE;&#x8868;&#xFF0C;&#x6BCF;&#x4E2A;&#x8282;&#x70B9;&#x79BB;&#x6563;&#x7684;&#x5206;&#x5E03;&#x5728;&#x5185;&#x5B58;&#x4E2D;&#xFF0C;&#x901A;&#x8FC7;next&#x6307;&#x9488;&#x5C06;&#x8282;&#x70B9;&#x8FDB;&#x884C;&#x8FDE;&#x63A5;(&#x53CC;&#x5411;&#x94FE;&#x8868;&#x591A;&#x4E00;&#x4E2A;&#x6307;&#x9488;pre)&#x3002;&#x7531;&#x4E8E;&#x5B58;&#x5728;&#x989D;&#x5916;&#x7684;&#x6307;&#x9488;&#xFF0C;&#x5185;&#x5B58;&#x7A7A;&#x95F4;&#x4F1A;&#x6BD4;&#x6B63;&#x5E38;&#x5B58;&#x50A8;&#x6570;&#x636E;&#x8981;&#x591A;&#x4E00;&#x4E9B;&#x3002; &#x4E00;&#x822C;&#x7ED3;&#x6784;&#x5355;&#x94FE;&#x8868;&#x8282;&#x70B9;1234struct Node{ TYPE val; struct Node* next;}; &#x53CC;&#x5411;&#x94FE;&#x8868;&#x8282;&#x70B9;12345struct Node{ TYPE val; struct Node* pre; struct Node* next;}; &#x4E00;&#x822C;&#x64CD;&#x4F5C;&#x94FE;&#x8868;&#x7684;&#x5EFA;&#x7ACB;&#x6B64;&#x5904;&#x8BA8;&#x8BBA;&#x7684;&#x662F;&#x4E0D;&#x5305;&#x542B;&#x5934;&#x6307;&#x9488;&#x7684;&#x94FE;&#x8868; &#x5934;&#x63D2;&#x6CD5;&#x6BCF;&#x6B21;&#x65B0;&#x6DFB;&#x52A0;&#x7684;&#x8282;&#x70B9;&#x90FD;&#x53D8;&#x4E3A;&#x5934;&#x8282;&#x70B9;&#x3002; &#x6BCF;&#x6B21;&#x6DFB;&#x52A0;&#x4E00;&#x4E2A;&#x8282;&#x70B9;1234567typedef TYPE int;Node * insert(Node*head,TYPE val){ Node * p = new Node(); p-&gt;val = val; p-&gt;next = head; return p;} &#x4E00;&#x6B21;&#x6DFB;&#x52A0;&#x6240;&#x6709;123456789101112131415Node * create_head(){ // &#x5934;&#x63D2;&#x6CD5; Node * p=NULL; Node * head = NULL; int val; cin &gt;&gt; val; while(val !=-1){ p = new Node(); p-&gt;val = val; p-&gt;next = head; head = p; cin &gt;&gt; val; } return head;} &#x5C3E;&#x63D2;&#x6CD5;&#x6BCF;&#x6B21;&#x8FDB;&#x6765;&#x7684;&#x8282;&#x70B9;&#x4E3A;&#x94FE;&#x8868;&#x7684;&#x5C3E;&#x63D2;&#x5165;&#x5230;&#x6700;&#x540E;&#x3002;&#x6BCF;&#x6B21;&#x6DFB;&#x52A0;&#x4E00;&#x4E2A;&#x8282;&#x70B9;1234567891011121314Node * insert_tail(Node*head,TYPE val){ //&#x5C3E;&#x63D2;&#x6CD5;&#xFF0C;&#x5982;&#x679C;head == NULL &#x8FD4;&#x56DE; &#x8282;&#x70B9; &#x5426;&#x5219;&#x8FD4;&#x56DE; NULL Node * p = new Node(); p-&gt;val = val; p-&gt;next = NULL; if(head == NULL){ return p; } while(head-&gt;next!=NULL){ head = head-&gt;next; } head-&gt;next = p; return NULL;} &#x4E00;&#x6B21;&#x6DFB;&#x52A0;&#x6240;&#x6709;123456789101112131415161718192021Node * create_tail(){ // &#x5C3E;&#x63D2;&#x6CD5; Node * tail=NULL; Node * p = NULL; Node * head = NULL; int val; cin &gt;&gt; val; while(val !=-1){ p = new Node(); p-&gt;val = val; if(head == NULL){ head = p; }else{ tail-&gt;next = p; } tail = p; cin &gt;&gt; val; } tail-&gt;next = NULL; return head;} &#x63D2;&#x5165;&#x6570;&#x636E;&#x63D2;&#x5165;&#x5230;&#x7B2C;n&#x4E2A;&#x8282;&#x70B9;&#x4E4B;&#x540E;,&#x5206;3&#x4E2D;&#x60C5;&#x51B5; 1 &#x5934;&#x8282;&#x70B9;&#x4E3A;&#x7A7A;&#xFF0C;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;&#x65B0;&#x7684;&#x8282;&#x70B9;2&#x90FD;&#x8282;&#x70B9;&#x4E0D;&#x4E3A;&#x7A7A;&#xFF0C;&#x4F46;&#x662F;&#x6CA1;&#x6709;n&#x4E2A;&#x8282;&#x70B9;&#xFF0C;&#x76F4;&#x63A5;&#x63D2;&#x5165;&#x5230;&#x6700;&#x540E;3&#x6B63;&#x5E38;&#x63D2;&#x5165;&#x5230;&#x7B2C;n&#x4E2A;&#x8282;&#x70B9;&#x540E;&#x9762;&#x3002; 1234567891011121314151617181920212223Node * insert_n(Node * head,TYPE val,int n){ //&#x63D2;&#x5165;&#x5230;&#x7B2C;n&#x4E2A;&#x5143;&#x7D20;&#x4E4B;&#x540E;&#xFF0C;&#x5982;&#x679C;&#x6CA1;&#x6709;n&#x4E2A;&#xFF0C;&#x76F4;&#x63A5;&#x63D2;&#x5165;&#x5230;&#x6700;&#x540E; //head &#x4E3A;NULL &#x8FD4;&#x56DE;&#x65B0;head&#xFF0C;&#x5426;&#x5219;&#x8FD4;&#x56DE;NULL Node *p = new Node(); p-&gt;val = val; if(head == NULL){ p-&gt;next = NULL; return p; } int count = 1; while(count&lt;n &amp;&amp; head-&gt;next){ head = head-&gt;next; ++count; } if(n == count){ p-&gt;next = head-&gt;next; head-&gt;next = p; }else{ head-&gt;next = p; p-&gt;next = NULL; } return NULL;} &#x5220;&#x9664;&#x6570;&#x636E;&#x5220;&#x9664;&#x7B2C;n&#x4E2A;&#x8282;&#x70B9;&#x7684;&#x6570;&#x636E; 1 &#x5934;&#x8282;&#x70B9;&#x4E3A;&#x7A7A;&#xFF0C;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;&#x7A7A;2 &#x5220;&#x9664;&#x7684;&#x6570;&#x636E;&#x4E3A;&#x5934;&#x8282;&#x70B9;&#xFF0C;&#x94FE;&#x8868;&#x53EA;&#x6709;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#xFF0C;&#x8FD4;&#x56DE;&#x7A7A;3 &#x5220;&#x9664;&#x7684;&#x6570;&#x636E;&#x4E3A;&#x5934;&#x8282;&#x70B9;&#xFF0C;&#x94FE;&#x8868;&#x4E0D;&#x53EA;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#xFF0C;&#x8FD4;&#x56DE;&#x4E4B;&#x540E;&#x7684;&#x8282;&#x70B9;4 &#x6B63;&#x5E38;&#x5220;&#x9664;&#x7B2C;n&#x4E2A;&#x8282;&#x70B9;&#x7684;&#x6570;&#x636E;&#xFF08;&#x6216;&#x6CA1;&#x6709;&#x7B2C;n&#x4E2A;&#x8282;&#x70B9;&#xFF09;&#xFF0C;&#x8FD4;&#x56DE;&#x5934;&#x8282;&#x70B9; 1234567891011121314151617181920212223242526272829Node * delete_n(Node *head,int n){ // 1 &#x5934;&#x8282;&#x70B9;&#x4E3A;&#x7A7A;&#xFF0C;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;&#x7A7A; // 2 &#x5220;&#x9664;&#x7684;&#x6570;&#x636E;&#x4E3A;&#x5934;&#x8282;&#x70B9;&#xFF0C;&#x94FE;&#x8868;&#x53EA;&#x6709;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#xFF0C;&#x8FD4;&#x56DE;&#x7A7A; // 3 &#x5220;&#x9664;&#x7684;&#x6570;&#x636E;&#x4E3A;&#x5934;&#x8282;&#x70B9;&#xFF0C;&#x94FE;&#x8868;&#x4E0D;&#x53EA;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#xFF0C;&#x8FD4;&#x56DE;&#x4E4B;&#x540E;&#x7684;&#x8282;&#x70B9; // 4 &#x6B63;&#x5E38;&#x5220;&#x9664;&#x7B2C;n&#x4E2A;&#x8282;&#x70B9;&#x7684;&#x6570;&#x636E;&#xFF08;&#x6216;&#x6CA1;&#x6709;&#x7B2C;n&#x4E2A;&#x8282;&#x70B9;&#xFF09;&#xFF0C;&#x8FD4;&#x56DE;&#x5934;&#x8282;&#x70B9; // n &#x4ECE;1&#x5F00;&#x59CB; if(head == NULL || n&lt;=0){ return head; } int count = 1; Node *p = head; if(n == 1){ head = p-&gt;next; delete p; return head; } while(count &lt;n-1 &amp;&amp; p-&gt;next){ ++count; p = p-&gt;next; } if(count == n-1){ Node * q = p-&gt;next; if(q!=NULL){ p-&gt;next = q-&gt;next; delete q; } } return head;} &#x67E5;&#x627E;&#x67E5;&#x627E;&#x7ED9;&#x5B9A;&#x7684;val&#x662F;&#x5426;&#x5B58;&#x5728;&#xFF0C;&#x5B58;&#x5728;&#x8FD4;&#x56DE;true,&#x4E0D;&#x5B58;&#x5728;&#x8FD4;&#x56DE;false12345678910bool find(Node* head,TYPE val){ while(head){ if(head-&gt;val == val){ return true; }else{ head = head-&gt;next; } } return false;} &#x4E00;&#x822C;&#x8003;&#x70B9; &#x90E8;&#x5206;&#x53C2;&#x8003;&#x6765;&#x6E90;&#x94FE;&#x8868;&#x53CD;&#x8F6C;&#x521D;&#x59CB;&#x94FE;&#x8868;&#xFF0C;p&#x4E3A;&#x7A7A;&#x6307;&#x9488;&#xFF0C;q&#x6307;&#x5411;&#x5934;&#x8282;&#x70B9;&#x6307;&#x9488;t&#x6307;&#x5411;q&#x7684;&#x4E0B;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#xFF0C;&#x5C06;q&#x7684;&#x4E0B;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x6307;&#x5411;p&#xFF0C;&#x5373;&#x5C06;q&#x7684;&#x7EA2;&#x8272;&#x7BAD;&#x5934;&#x53D8;&#x4E3A;&#x7EFF;&#x8272;&#x7BAD;&#x5934;&#x3002;p &#x53D8;&#x6210;q,q&#x53D8;&#x6210;t&#xFF0C;&#x5373;&#x56FE;&#x4E2D;&#x7EA2;&#x8272;&#x6307;&#x9488;&#x53D8;&#x4E3A;&#x7EFF;&#x8272;&#x6307;&#x9488;&#x5FAA;&#x73AF;&#x6267;&#x884C;2&#x548C;3 &#x76F4;&#x5230; q == NULL&#x4E3A;&#x6B62;&#xFF0C;&#x8FD4;&#x56DE;p.123456789101112Node * reverse(Node* head){ Node* p = 0; Node* q = head; Node* t = NULL; while(q!=NULL){ t = q-&gt;next; q-&gt;next = p; p = q; q = t; } return p;} &#x4E24;&#x4E2A;&#x94FE;&#x8868;&#x627E;&#x4EA4;&#x53C9;&#x8282;&#x70B9;(&#x5224;&#x65AD;&#x662F;&#x5426;&#x76F8;&#x4EA4;)&#x5BF9;&#x9F50;&#x6CD5;&#x5982;&#x56FE;&#xFF0C;&#x5982;&#x679C;&#x627E;&#x5230;&#x4E24;&#x4E2A;&#x94FE;&#x8868;&#x7684;&#x5934;&#x90E8;&#x5BF9;&#x9F50;&#x7684;&#x8D77;&#x70B9;&#xFF0C;&#x7136;&#x540E;&#x4E24;&#x4E2A;&#x94FE;&#x8868;&#x4E00;&#x6B21;&#x79FB;&#x52A8;&#x5E76;&#x5224;&#x65AD;&#x4E00;&#x4E2A;&#xFF0C;&#x76F8;&#x7B49;&#x65F6;&#xFF0C;&#x5C31;&#x4E3A;&#x627E;&#x5230;&#x7684;&#x4EA4;&#x70B9;&#xFF0C;&#x5426;&#x5219;&#x5C31;&#x4E0D;&#x76F8;&#x4EA4;&#x3002;&#x5BF9;&#x4E24;&#x4E2A;&#x94FE;&#x8868;&#x8BA1;&#x6570;&#xFF0C;&#x957F;&#x7684;&#x94FE;&#x8868;&#x6709;countA&#x4E2A;&#x8282;&#x70B9;,&#x77ED;&#x7684;&#x94FE;&#x8868;&#x6709;countB&#x4E2A;&#x8282;&#x70B9;&#x3002;&#x5148;&#x79FB;&#x52A8;&#x77ED;&#x7684;&#x94FE;&#x8868;&#xFF0C;&#x79FB;&#x52A8;(countA - countB)&#x4E2A;&#x4F4D;&#x7F6E;&#xFF0C;&#x7136;&#x540E;&#x4E24;&#x4E2A;&#x94FE;&#x8868;&#x4E00;&#x8D77;&#x79FB;&#x52A8;&#x5E76;&#x5224;&#x65AD;&#x662F;&#x5426;&#x76F8;&#x7B49;&#x3002;&#x76F8;&#x7B49;&#x5C31;&#x662F;&#x4EA4;&#x53C9;&#x70B9;&#xFF0C;&#x79FB;&#x52A8;&#x5230;&#x7ED3;&#x5C3E;&#x90FD;&#x4E0D;&#x76F8;&#x7B49;&#x5219;&#x4E0D;&#x76F8;&#x4EA4;&#x3002; &#x65F6;&#x95F4;&#x590D;&#x6742;&#x5EA6; O(A+B) &#x7A7A;&#x95F4;&#x590D;&#x6742;&#x5EA6; O(1)&#x4E0D;&#x4F1A;&#x7834;&#x73AF;&#x539F;&#x6765;&#x7684;&#x94FE;&#x8868;&#x7ED3;&#x6784; &#x73AF;&#x627E;&#x5165;&#x53E3;&#x70B9;&#x6CD5;&#x8FD9;&#x79CD;&#x65B9;&#x6CD5;&#x5176;&#x5B9E;&#x662F;&#x8F6C;&#x5316;&#x4E3A;&#x627E;&#x5E26;&#x73AF;&#x7684;&#x94FE;&#x8868;&#x7684;&#x5165;&#x53E3;&#x70B9;&#xFF0C;&#x5C06;&#x5176;&#x4E2D;&#x4E00;&#x6761;&#x94FE;&#x8868;&#x7684;&#x9996;&#x5C3E;&#x76F8;&#x8FDE;&#x3002;&#x5177;&#x4F53;&#x89E3;&#x53D1;&#x89C1;&#x627E;&#x201D;&#x94FE;&#x8868;&#x73AF;&#x6240;&#x5728;&#x4F4D;&#x7F6E;&#x201D; &#x54C8;&#x5E0C;&#x89E3;&#x6CD5;&#x5C06;&#x7B2C;&#x4E00;&#x4E2A;&#x94FE;&#x8868;&#x7684;&#x8282;&#x70B9;&#x5730;&#x5740;&#x5B58;&#x5230;&#x54C8;&#x5E0C;&#x8868;&#x4E2D;&#xFF0C;&#x7136;&#x540E;&#x904D;&#x5386;&#x7B2C;&#x4E8C;&#x4E2A;&#x94FE;&#x8868;&#xFF0C;&#x627E;&#x5230;&#x7B2C;&#x4E00;&#x4E2A;&#x5B58;&#x5728;&#x4E8E;&#x54C8;&#x5E0C;&#x8868;&#x4E2D;&#x7684;&#x8282;&#x70B9;&#x5C31;&#x662F;&#x4EA4;&#x53C9;&#x8282;&#x70B9;&#x3002; &#x65F6;&#x95F4;&#x590D;&#x6742;&#x5EA6; O(A+B) &#x7A7A;&#x95F4;&#x590D;&#x6742;&#x5EA6; O(A) &#x627E;&#x94FE;&#x8868;&#x73AF;&#x5165;&#x53E3;&#x6240;&#x5728;&#x4F4D;&#x7F6E;&#x5982;&#x56FE;&#x6240;&#x793A;&#xFF0C;&#x5047;&#x8BBE;&#x9ED1;&#x8272;&#x7684;A&#x8282;&#x70B9;&#x7ED5;&#x8FDB;&#x5230;&#x5708;&#x5185;&#xFF0C;&#x548C;&#x7EA2;&#x8272;&#x7684;A&#x91CD;&#x5408;&#x4E86;&#x3002;&#x5C06;&#x7EA2;&#x8272;A&#x4F5C;&#x4E3A;&#x8D77;&#x70B9;&#xFF0C;&#x4E24;&#x4E2A;&#x6307;&#x9488;&#xFF0C;&#x4E00;&#x4E2A;&#x8D70;&#x4E00;&#x6B65;&#xFF0C;&#x4E00;&#x4E2A;&#x8D70;&#x4E24;&#x6B65;&#x3002;&#x7B2C;&#x4E00;&#x6B21;&#x76F8;&#x4EA4;&#x7684;&#x4F4D;&#x7F6E;&#x4F1A;&#x5728;&#x8D77;&#x70B9;&#x3002;&#x6B64;&#x65F6;&#x4E00;&#x4E2A;&#x6307;&#x9488;&#x5728;&#x7EA2;A,&#x4E00;&#x4E2A;&#x6307;&#x9488;&#x5728;&#x9ED1;A,&#x540C;&#x65F6;&#x90FD;&#x8D70;&#x4E00;&#x6B65;&#xFF0C;&#x4E24;&#x4E2A;&#x8282;&#x70B9;&#x76F8;&#x7B49;&#x65F6;&#x627E;&#x5230;&#x73AF;&#x7684;&#x5165;&#x53E3;&#x8282;&#x70B9;B&#x3002; 12345678910111213141516171819202122232425Node * has_ring(Node * head){ //&#x6709;&#x73AF;&#x8FD4;&#x56DE;&#x73AF;&#x7684;&#x5165;&#x53E3;&#xFF0C;&#x5426;&#x5219;&#x8FD4;&#x56DE;NULL,&#x4E0D;&#x53EF;&#x4EE5;&#x6539;&#x53D8;&#x539F;&#x94FE;&#x8868; if(head == NULL || head-&gt;next == NULL){ return head; } Node* slow = head-&gt;next; Node* fast = head-&gt;next-&gt;next; while(fast&amp;&amp;fast-&gt;next!=NULL &amp;&amp; fast!=slow){ slow = slow-&gt;next; fast = fast-&gt;next; if(fast){ fast = fast-&gt;next; } } if(fast == slow){ fast = head; while(slow != fast){ slow = slow-&gt;next; fast = fast-&gt;next; } return fast; } return NULL;} &#x6C42;&#x5012;&#x6570;k&#x4E2A;&#x8282;&#x70B9;&#x5148;&#x8BA9;p&#x6307;&#x9488;&#x4ECE;head&#x79FB;&#x52A8;k&#x4E2A;&#x8282;&#x70B9;&#xFF0C;&#x6B64;&#x65F6;&#x8BA9;a&#x6307;&#x9488;&#x6307;&#x5411;head&#xFF0C;p&#x548C;a&#x540C;&#x65F6;&#x79FB;&#x52A8;&#xFF0C;p&#x5230;&#x8FBE;&#x94FE;&#x8868;&#x5C3E;&#x90E8;&#x65F6;&#xFF0C;a&#x5230;&#x8FBE;&#x5012;&#x6570;&#x7B2C;k&#x4E2A;&#x4F4D;&#x7F6E;&#x3002;123456789101112131415161718192021Node *countdown_k(Node* head,int k){ //&#x5012;&#x6570;k&#x4E2A;&#x8282;&#x70B9; if(k&lt;1){ return NULL; } int count = 0; Node *p = head; while(count&lt;k &amp;&amp; p!=NULL){ p = p-&gt;next; ++count; } if(p){ Node*a = head; while(p-&gt;next){ p = p-&gt;next; a = a-&gt;next; } return a-&gt;next; } return NULL;} &#x4EE3;&#x7801;&#x6574;&#x7406;&#x70B9;&#x51FB;&#x8FD9;&#x91CC;]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>基础练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LR-逻辑斯蒂回归]]></title>
    <url>%2Fblog%2F2019%2F04%2F03%2F%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2FLR%2FLR%2F</url>
    <content type="text"><![CDATA[&#x4E2A;&#x4EBA;&#x7406;&#x89E3; &#x5206;&#x7C7B;&#x8FC7;&#x7A0B;&#x5C31;&#x662F;&#x4F7F;&#x5F97;&#x6837;&#x672C;&#x5206;&#x5230;&#x5BF9;&#x5E94;&#x5206;&#x7C7B;&#x7684;&#x6982;&#x7387;&#x6700;&#x5927;&#x3002; &#x4EE3;&#x7801;]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>LR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[朴素贝叶斯]]></title>
    <url>%2Fblog%2F2019%2F04%2F02%2F%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%2FNaiveBayes%2F</url>
    <content type="text"><![CDATA[&#x4E2A;&#x4EBA;&#x7406;&#x89E3; &#x57FA;&#x4E8E;&#x5F3A;&#x5047;&#x8BBE; -&#x6761;&#x4EF6;&#x72EC;&#x7ACB;&#x6027;&#x5047;&#x8BBE;&#xFF0C;&#x76F8;&#x5173;&#x6027;&#x8D8A;&#x5F3A;&#x7684;&#x7279;&#x5F81;&#x9884;&#x6D4B;&#x6548;&#x679C;&#x8D8A;&#x5DEE;&#xFF0C;&#x53CD;&#x4E4B;&#x8D8A;&#x597D; &#x5B8C;&#x5168;&#x6839;&#x636E;&#x7EDF;&#x8BA1;&#x6982;&#x7387;&#x8BA1;&#x7B97;&#x5728;&#x5F53;&#x524D;&#x7279;&#x5F81;&#x4E0B;&#xFF0C;&#x5404;&#x4E2A;&#x5206;&#x7C7B;&#x7684;&#x6982;&#x7387;&#xFF0C;&#x53D6;&#x6982;&#x7387;&#x6700;&#x9AD8;&#x7684;&#x5206;&#x7C7B;&#x4F5C;&#x4E3A;&#x7ED3;&#x679C;&#x3002; &#x4E00;&#x822C;&#x6709;&#x4E09;&#x79CD; &#x7279;&#x5F81;&#x662F;&#x79BB;&#x6563;&#x7684;&#xFF0C;&#x53EF;&#x5047;&#x8BBE;&#x7279;&#x5F81;&#x670D;&#x4ECE;&#x591A;&#x9879;&#x5F0F;&#x5206;&#x5E03;&#xFF0C;&#x6982;&#x7387;&#x8BA1;&#x7B97;&#x6309;&#x7167;&#x591A;&#x9879;&#x5F0F;&#x516C;&#x5F0F; P = (Nci + alpha)/(Nc + o*alpha) &#x8BA1;&#x7B97; Nci &#x8868;&#x793A;&#x7C7B;&#x522B;&#x4E3A;c,&#x7279;&#x5F81;&#x4E3A;i&#x7684;&#x4E2A;&#x6570;&#xFF0C;Nc&#x8868;&#x793A;&#x7C7B;&#x522B;&#x4E3A;c&#x7684;&#x4E2A;&#x6570;&#xFF0C;alpha &#x4E00;&#x822C;&#x53D6;1 o &#x8868;&#x793A;&#x7C7B;&#x522B;c&#x4E0B; &#x7279;&#x5F81;i&#x7684;&#x53D6;&#x503C;&#x4E2A;&#x6570; &#x7279;&#x5F81;&#x662F;&#x79BB;&#x6563;&#x7A00;&#x758F;&#x7684;&#xFF0C;&#x53EF;&#x5047;&#x8BBE;&#x7279;&#x5F81;&#x670D;&#x4ECE;&#x4F2F;&#x52AA;&#x5229;&#x5206;&#x5E03;&#xFF0C;&#x6982;&#x7387;&#x6309;&#x7167;&#x4F2F;&#x52AA;&#x5229;&#x516C;&#x5F0F;&#x8BA1;&#x7B97;&#xFF0C;&#x6240;&#x6709;&#x7279;&#x5F81;&#x53D6;&#x503C;&#x4E3A;0&#x548C;1 &#xFF0C;&#x51FA;&#x73B0;&#x8BE5;&#x7279;&#x5F81;&#x8BB0;&#x4E3A;1&#xFF0C;&#x4E0D;&#x7BA1;&#x51FA;&#x73B0;&#x7684;&#x6B21;&#x6570;&#x3002; &#x7279;&#x5F81;&#x662F;&#x8FDE;&#x7EED;&#x7684;&#xFF0C;&#x53EF;&#x5047;&#x8BBE;&#x7279;&#x5F81;&#x670D;&#x4ECE;&#x9AD8;&#x65AF;&#x5206;&#x5E03;&#xFF0C;&#x6982;&#x7387;&#x8BA1;&#x7B97; &#x4EE3;&#x7801;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170import numpy as npfrom sklearn.naive_bayes import GaussianNB as GNBfrom sklearn.naive_bayes import MultinomialNB as MNBfrom sklearn.naive_bayes import BernoulliNB as BNBclass NaiveBayes(): def __init__(self): self.P_C_F = {} # &#x8868;&#x793A;&#x5728;&#x5206;&#x7C7B;&#x4E3A;C&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;F&#x7684;&#x6982;&#x7387; self.P_C = {} # &#x8868;&#x793A;&#x5728;&#x5206;&#x7C7B;&#x4E3A;C&#x7684;&#x6982;&#x7387; self.P_F = {} # &#x8868;&#x793A;&#x7279;&#x5F81;F&#x7684;&#x6982;&#x7387; def train(self,dataSet,k=1,lamda=1): # dataSet &#x4E3A;np.array &#x6700;&#x540E;&#x4E00;&#x4F4D;&#x4E3A;&#x6807;&#x7B7E; # lamda&#x7684;&#x53D6;&#x503C;&#x8303;&#x56F4;&#x662F;[0,1]&#xFF0C;&#x6BD4;&#x8F83;&#x5E38;&#x89C1;&#x7684;&#x662F;&#x53D6;&#x503C;&#x4E3A;1&#x3002; self.dataSet = dataSet # &#x8BA1;&#x7B97;&#x6982;&#x7387; clazz = list(set(dataSet[:,-1])) clazzNum = len(clazz) # &#x5206;&#x7C7B;&#x6570; for i in clazz: self.P_C[i] = len(dataSet[dataSet[:,-1] == i,-1])/len(dataSet) for fea_index in range(dataSet.shape[1]-1): features = list(set(dataSet[:,fea_index])) for fe in features: if self.P_F.get(fea_index) is None: self.P_F[fea_index] = {} f_num = len(dataSet[dataSet[:,fea_index] == fe,fea_index]) self.P_F[fea_index][fe] = f_num*1.0/dataSet.shape[0] for cla in clazz: for fea_index in range(dataSet.shape[1]-1): features = list(set(dataSet[:,fea_index])) # print(cla,fea_index) for fe in features: if self.P_C_F.get(cla) is None: self.P_C_F[cla] = {} if self.P_C_F[cla].get(fea_index) is None: self.P_C_F[cla][fea_index] = {} p1 = len(dataSet[(dataSet[:,-1] == cla) &amp; (dataSet[:,fea_index] == fe),-1]) # &#x5206;&#x7C7B;&#x4E3A;cla &#x7B2C;fea_index&#x4E2A;&#x7279;&#x5F81;&#x4E3A;fe&#x7684;&#x4E2A;&#x6570; p2 = len(dataSet[dataSet[:,-1] == cla,-1]) # &#x5206;&#x7C7B;&#x662F;cla&#x7684;&#x4E2A;&#x6570; self.P_C_F[cla][fea_index][fe] = (p1*1.0 + lamda)/(p2+k*lamda) def classifier(self,features): # &#x4F8B;&#x5982; feature = [3,&apos;S&apos;,1] # P(C|F) = P(F|C)*P(C) / P(F) # P(C|f1,f2,f3) = P(f1|C)*P(f2|C)*P(f3|C)*P(C) / P(f1)*P(f2)*P(f3) # &#x8BA1;&#x7B97;&#x5404;&#x4E2A;&#x5206;&#x7C7B;&#x7684;&#x6982;&#x7387;&#xFF0C;&#x6700;&#x540E;&#x8F93;&#x51FA;&#x6982;&#x7387;&#x6700;&#x9AD8;&#x7684;&#x7ED3;&#x679C; result = [] if type(features) == type(np.array([])) and type(features[0]) == type(np.array([])): for feature in features: P = {} for c in self.P_C: pf_one = 1 pcf_one = 1 for index in range(len(feature)): try: pf_one *= self.P_F[index][feature[index]] pcf_one *= self.P_C_F[c][index][feature[index]] except KeyError as e: pf_one *= 1 pcf_one *= 1 # print(&apos;&#x51FA;&#x73B0;&#x4E86;&#x8BAD;&#x7EC3;&#x65F6;&#x6CA1;&#x6709;&#x51FA;&#x73B0;&#x7684;&#x7279;&#x5F81; &apos;) P[c] = pcf_one*self.P_C[c] / pf_one result.append(max(P, key=P.get)) else: P = {} feature = features for c in self.P_C: pf_one = 1 pcf_one = 1 for index in range(len(feature)): pf_one *= self.P_F[index][feature[index]] pcf_one *= self.P_C_F[c][index][feature[index]] P[c] = pcf_one*self.P_C[c] / pf_one result.append(max(P, key=P.get)) # print(sorted(P.items(), key=lambda x: x[1], reverse=True)[0][0] ) # print(max(P, key=P.get)) # print(&apos;result is &apos;,result) return result def loadData(self,filepath,split_char = &apos;\t&apos;,floats = False,ignore_firstline = False,f=None): # &#x52A0;&#x8F7D;&#x6570;&#x636E;&#x96C6; dataSet = [] if f is None: f = {} # &#x6620;&#x5C04;&#x5173;&#x7CFB; with open(filepath) as file: for line in file.readlines(): if ignore_firstline: ignore_firstline = False continue currline = line.strip().split(split_char)# &#x53BB;&#x524D;&#x540E;&#x7A7A;&#x683C; &#x8F6C;&#x6570;&#x7EC4; fltLine = [] for i,ele in enumerate(currline): if floats: try: fltLine.append(float(ele)) except ValueError as e: # &#x662F;&#x5B57;&#x7B26;&#x4E32;&#xFF0C;&#x5C06;&#x5176;&#x6309;&#x7167;&#x51FA;&#x73B0;&#x7684;&#x987A;&#x5E8F;&#x6620;&#x5C04;&#x4E3A;0 1 2 3 &#x7B49;&#x7B49; if f.get(i) is None: f[i] = {} if ele not in f[i]: f[i][ele] = len(f[i]) fltLine.append(f[i][ele]) else: fltLine.append(ele) dataSet.append(fltLine) return np.array(dataSet),fdef print_dict(src_dict, level=0, src_dict_namestr=&apos;&apos;): # https://blog.csdn.net/u012421852/article/details/79840409 &apos;&apos;&apos; &#x9010;&#x884C;&#x6253;&#x5370;dict :param self:&#x7C7B;&#x5B9E;&#x4F8B;&#x81EA;&#x8EAB; :param src_dict:&#x88AB;&#x6253;&#x5370;&#x7684;dict :param level:&#x9012;&#x5F52;level&#xFF0C;&#x521D;&#x6B21;&#x8C03;&#x7528;&#x4E3A;level=0 :param src_dict_namestr:&#x5BF9;&#x8C61;&#x53D8;&#x91CF;&#x540D;&#x79F0;&#x5B57;&#x7B26;&#x4E32; &apos;&apos;&apos; if isinstance(src_dict, dict): tab_str = &apos;\t&apos; for i in range(level): tab_str += &apos;\t&apos; if 0 == level: print(src_dict_namestr,&apos;= {&apos;) for key, value in src_dict.items(): if isinstance(value, dict): has_dict = False for k,v in value.items(): if isinstance(v, dict): has_dict = True if has_dict: print(tab_str,key,&quot;:{&quot;) print_dict(value, level + 1) else: print(tab_str,key,&apos;:&apos;,value) else: print(tab_str,key,&apos;: &apos;,value,) print(tab_str,&apos;}&apos;)if __name__ == &quot;__main__&quot;: NB = NaiveBayes() dataSet,f= NB.loadData(&apos;../data/train_modified.csv&apos;,split_char=&apos;,&apos;,floats = True,ignore_firstline=False) test_dataSet,f = NB.loadData(&apos;../data/test_modified.csv&apos;,split_char=&apos;,&apos;,floats = True,ignore_firstline=False,f=f) # dataSet,f= NB.loadData(&apos;naivebayes_data.csv&apos;,split_char=&apos;,&apos;,floats = True,ignore_firstline=False) NB.train(dataSet) result = NB.classifier(dataSet[:,0:-1]) print(&quot;train dataSet len :&quot;,len(dataSet)) print(&quot;the correct number of train predict &quot;,sum(result== dataSet[:,-1])) result = NB.classifier(test_dataSet[:,0:-1]) print(&quot;test dataSet len :&quot;,len(test_dataSet)) print(&quot;the correct number of test predict &quot;,sum(result== test_dataSet[:,-1])) # sklearn clf = MNB() clf.fit(dataSet[:,0:-1],dataSet[:,-1]) predict = clf.predict(test_dataSet[:,0:-1]) print(&quot;MNB:&quot;,sum(predict == test_dataSet[:,-1])) clf = GNB() clf.fit(dataSet[:,0:-1],dataSet[:,-1]) predict = clf.predict(test_dataSet[:,0:-1]) print(&quot;GNB:&quot;,sum(predict == test_dataSet[:,-1])) clf = BNB() clf.fit(dataSet[:,0:-1],dataSet[:,-1]) predict = clf.predict(test_dataSet[:,0:-1]) print(&quot;BNB:&quot;,sum(predict == test_dataSet[:,-1])) 1# &#x7ED3;&#x679C; train dataSet len : 20001the correct number of train predict 19903test dataSet len : 5533the correct number of test predict 5532MNB: 3496GNB: 5514BNB: 5532` &#x53C2;&#x8003;https://www.cnblogs.com/pinard/p/6069267.html]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习，贝叶斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LSTM]]></title>
    <url>%2Fblog%2F2019%2F04%2F02%2F%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2FLSTM%2FLSTM%2F</url>
    <content type="text"><![CDATA[LSTM(Long short-term memory)&#x5148;&#x770B;&#x7EC6;&#x8282;&#x7684;&#x7ED3;&#x6784;&#x56FE;&#x56FE;&#x4E2D;&#x4E2D;&#x95F4;&#x5757;&#x6709;4&#x4E2A;&#x9EC4;&#x8272;&#x7684;&#x6846;&#xFF0C;&#x4ECE;&#x5DE6;&#x5230;&#x53F3;f(&#x5FD8;&#x8BB0;&#x95E8;) i(&#x8F93;&#x5165;&#x95E8;1) a(&#x8F93;&#x5165;&#x95E8;2) o(&#x8F93;&#x51FA;&#x95E8;)&#xFF0C;&#x8F93;&#x5165;&#x95E8;&#x4E0D;&#x592A;&#x4E25;&#x8C28;&#xFF0C;&#x5148;&#x8FD9;&#x6837;&#x7406;&#x89E3;&#x3002;&#x6BCF;&#x4E2A;&#x95E8;&#x5BF9;&#x5E94;&#x7684;&#x516C;&#x5F0F;&#x4E3A; &#x516C;&#x5F0F; F = sigmoid[Wf*(Xt + ht-1) + bf]I = sigmoid[Wi*(Xt + ht-1) + bi]A = tanh[Wa*(Xt + ht-1) + ba]O = sigmoid[Wo*(Xt + ht-1) + bo]Ct = f*C(t-1) + I*AHt = tanh(Ct) O&#x6CE8;&#x610F;&#xFF0C;&#x8FD9;&#x91CC;&#x7684;+&#x548C;\&#x90FD;&#x8868;&#x793A;&#x5BF9;&#x5E94;&#x4F4D;&#x7F6E;&#x52A0;&#x6216;&#x8005;&#x4E58;&#xFF0C;&#x4E0D;&#x6539;&#x53D8;&#x77E9;&#x9635;&#x7684;&#x5F62;&#x72B6;&#x3002;&#x5404;&#x4E2A;&#x95E8;&#x7684;&#x6570;&#x636E;&#x5728;&#x8FD9;&#x91CC;&#x5E94;&#x8BE5;&#x90FD;&#x662F;(0,1)&#x7684;&#x6570;&#xFF0C;&#x5FD8;&#x8BB0;&#x95E8;&#x7684;f&#x548C;C(t-1)&#x76F8;&#x4E58;&#xFF0C;&#x4F1A;&#x53D8;&#x5C0F;&#xFF0C;&#x53EF;&#x7406;&#x89E3;&#x4E3A;&#x4E22;&#x5F03;&#x4E86;&#x4E00;&#x90E8;&#x5206;&#x4FE1;&#x606F;&#x3002;&#x800C;&#x8F93;&#x5165;&#x95E8;&#x548C;C(-)&#x76F8;&#x52A0;&#xFF0C;&#x4F1A;&#x53D8;&#x5927;&#xFF0C;&#x83B7;&#x5F97;&#x65B0;&#x7684;&#x4FE1;&#x606F;&#x3002;&#x8F93;&#x51FA;&#x95E8;&#xFF0C;&#x5C06;&#x539F;&#x6765;&#x7684;&#x6570;&#x636E;&#x548C;&#x65B0;&#x6570;&#x636E;&#x6574;&#x5408;&#xFF0C;&#x5F97;&#x5230;&#x65B0;&#x7684;&#x9690;&#x85CF;&#x6570;&#x636E;h&#x3002; &#x8F93;&#x5165;&#x8F93;&#x51FA;&#x7EC6;&#x8282;&#x4E0B;&#x9762;&#x8FD9;&#x5F20;&#x56FE;&#x662F;&#x6211;&#x89C9;&#x5F97;&#x8F93;&#x5165;&#x7EC6;&#x8282;&#x8868;&#x73B0;&#x7684;&#x6700;&#x597D;&#x7684; &#x6765;&#x6E90;&#x5BF9;&#x4E8E;&#x4E00;&#x4E2A;LSTM&#x7ED3;&#x6784;&#xFF0C;&#x53EF;&#x4EE5;&#x770B;&#x505A;&#x7531;&#x65F6;&#x95F4;&#x5E8F;&#xFF08;time_step&#xFF09;&#x4E2A;cell&#x6784;&#x6210;(&#x5B9E;&#x9645;&#x4E0A;&#x53EA;&#x6709;&#x4E00;&#x4E2A;&#xFF0C;&#x5728;&#x5FAA;&#x73AF;&#x7684;&#x8FC7;&#x7A0B;&#x4E2D;&#xFF0C;&#x516C;&#x7528;&#x4E00;&#x4E2A;cell)&#x3002;&#x6BCF;&#x4E2A;cell&#x5904;&#x7406;&#x4E00;&#x4E2A;&#x5355;&#x8BCD;&#x6784;&#x6210;&#x7684;&#x8BCD;&#x5411;&#x91CF;&#xFF0C;&#x8F93;&#x51FA;&#x9690;&#x85CF;&#x6570;&#x636E;h&#xFF0C;&#x5BF9;&#x4E8E;&#x8F93;&#x51FA;&#x7684;h,&#x53EF;&#x4EE5;&#x5C06;&#x5168;&#x90E8;&#x7528;&#x4F5C;&#x8F93;&#x51FA;&#xFF0C;&#x4E5F;&#x53EF;&#x4EE5;&#x53EA;&#x53D6;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#x7684;&#x6570;&#x636E;&#xFF0C;&#x8981;&#x770B;&#x6A21;&#x578B;&#x7684;&#x4F5C;&#x7528;&#x3002; &#x56FE;&#x4E2D;&#x6709;4&#x4E2A;&#x65F6;&#x95F4;&#x5E8F;&#x5217;&#xFF0C;&#x53EF;&#x4EE5;&#x5904;&#x7406;&#x4E00;&#x53E5;&#x8BDD;&#x7684;4&#x4E2A;&#x5355;&#x8BCD;&#xFF0C;&#x6BCF;&#x4E2A;&#x5355;&#x8BCD;&#x5411;&#x91CF;&#x5316;&#x540E;&#x662F;embedding&#x4E2A;&#x6570;&#x5B57;&#x7EC4;&#x6210;&#x7684;&#x5217;&#x5411;&#x91CF;&#xFF0C;embedding&#x4E0D;&#x56FA;&#x5B9A;&#x3002; &#x53C2;&#x6570;&#x8BA1;&#x7B97;&#x82E5;&#x6709;shape={13,8} &#x7684;&#x8F93;&#x5165;&#x6570;&#x636E;&#xFF0C;&#x8868;&#x793A;&#x5C06;&#x4E00;&#x4E2A;&#x542B;&#x6709;13&#x4E2A;&#x5355;&#x8BCD;&#x7684;&#x53E5;&#x5B50;&#xFF0C;&#x8F6C;&#x5316;&#x4E3A;&#x65F6;&#x95F4;&#x5E8F;&#x5217;&#x4E3A;13&#xFF0C;&#x8BCD;&#x5411;&#x91CF;&#x4E3A;8&#x7684;&#x6570;&#x636E;&#x3002;(&#x5C06;&#x4E00;&#x4E2A;&#x8BCD;&#x6620;&#x5C04;&#x4E3A;8&#x4E2A;&#x6570;&#x5B57;&#x8868;&#x793A;&#x7684;&#x5411;&#x91CF;)&#x3002;&#x8FD9;&#x91CC;embedding=8,time_step=13&#x3002;&#x5BF9;T=1&#x65F6;&#x523B;&#xFF0C;&#x53EA;&#x8F93;&#x5165;&#x7B2C;&#x4E00;&#x4E2A;&#x5355;&#x8BCD;&#x5BF9;&#x5E94;&#x7684;&#x5411;&#x91CF;X1(1,8),&#x82E5;&#x9690;&#x85CF;&#x5C42;&#x6709;6&#x4E2A;&#xFF0C;&#x5219;&#x5BF9;&#x4E8E;&#x76F8;&#x5173;&#x53C2;&#x6570;&#x7684;&#x4E2A;&#x6570;&#x6709; Wf = (8+6)*6 Bf = 6 &#x8BE5;&#x5C42;&#x5171;90&#x4E2A;&#x53C2;&#x6570;&#x5176;&#x4ED6;&#x53C2;&#x6570;&#x4E2A;&#x6570;&#x540C;&#x6837;&#xFF0C;&#x603B;&#x5171;&#x6709;90*4 = 360&#x4E2A;&#x53C2;&#x6570;&#xFF0C;&#x5982;&#x679C;&#x6700;&#x540E;&#x8FD8;&#x6709;&#x4E00;&#x4E2A;&#x5168;&#x8FDE;&#x63A5;&#x5C42;&#x7684;&#x8BDD;&#xFF0C;&#x8FD8;&#x5F97;&#x52A0;&#x4E0A;&#x76F8;&#x5E94;&#x7684;&#x4E2A;&#x6570;&#x3002; &#x4EE3;&#x7801;&#x76F4;&#x63A5;&#x8C03;&#x7528;&#x5E93;&#x4E2D;&#x7684;LSTM&#x5BF9;&#x5176;&#x7406;&#x89E3;&#x4E0D;&#x591F;&#x6DF1;&#x523B;&#xFF0C;&#x7528;tensorflow&#x5199;&#x4E86;&#x4E2A;&#x7B80;&#x5355;&#x7248;&#x672C;&#x7684;LSTM 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153# coding:utf-8# mrcat# 2019/04/02import tensorflow as tfimport numpy as npimport pandas as pdimport timefrom sklearn.preprocessing import MinMaxScalerimport matplotlib.pyplot as pltclass LSTMCell(): def __init__(self,config): self.num_hidden = config.num_hidden # &#x9690;&#x85CF;&#x5355;&#x5143;&#x4E2A;&#x6570; &#x4E5F;&#x5C31;&#x662F;h&#x7684;&#x4E2A;&#x6570; self.time_step = config.time_step # &#x65F6;&#x95F4;&#x6B65;&#x957F;,&#x5BF9;&#x53E5;&#x5B50;&#x800C;&#x8A00;&#x5C31;&#x662F;&#x4E00;&#x4E2A;&#x53E5;&#x5B50;&#x6709;&#x591A;&#x5C11;&#x4E2A;&#x5355;&#x8BCD; self.embedding = config.embedding # &#x8BCD;&#x5411;&#x91CF;&#x7684;&#x7EF4;&#x5EA6;, &#x4E00;&#x4E2A;&#x5355;&#x8BCD;&#x6700;&#x7EC8;&#x8F6C;&#x6362;&#x4E3A;&#x591A;&#x5C11;&#x7EF4;&#x7684;&#x5411;&#x91CF; self.x = config.x # shape (config.time_step,config.embedding),&#x53EA;&#x5904;&#x7406;&#x4E00;&#x53E5;&#x8BDD; self.params = {} w0 = self.num_hidden w1 = self.embedding+self.num_hidden self.params[&apos;wf&apos;] = self._init_weights([w0,w1]) # &#x5FD8;&#x8BB0;&#x95E8;&#x7684;&#x53C2;&#x6570; self.params[&apos;wi&apos;] = self._init_weights([w0,w1]) # &#x8F93;&#x5165;&#x95E8;&#x7684;&#x53C2;&#x6570; self.params[&apos;wa&apos;] = self._init_weights([w0,w1]) # tanh &#x7684;&#x53C2;&#x6570; self.params[&apos;wo&apos;] = self._init_weights([w0,w1]) # &#x8F93;&#x51FA;&#x95E8;&#x7684;&#x53C2;&#x6570; self.params[&apos;bf&apos;] = self._init_weights([w0,1]) # &#x5FD8;&#x8BB0;&#x95E8;&#x7684;&#x53C2;&#x6570; self.params[&apos;bi&apos;] = self._init_weights([w0,1]) # &#x8F93;&#x5165;&#x95E8;&#x7684;&#x53C2;&#x6570; self.params[&apos;ba&apos;] = self._init_weights([w0,1]) # tanh &#x7684;&#x53C2;&#x6570; self.params[&apos;bo&apos;] = self._init_weights([w0,1]) # &#x8F93;&#x51FA;&#x95E8;&#x7684;&#x53C2;&#x6570; self.states = {} self.states[&apos;f&apos;] = self._init_weights([w0,1]) # &#x5FD8;&#x8BB0;&#x95E8; self.states[&apos;i&apos;] = self._init_weights([w0,1]) # &#x8F93;&#x5165;&#x95E8; self.states[&apos;a&apos;] = self._init_weights([w0,1]) # &#x95E8; self.states[&apos;o&apos;] = self._init_weights([w0,1]) # &#x8F93;&#x51FA;&#x95E8; self.states[&apos;h&apos;] = self._init_weights([w0,1]) # &#x9690;&#x85CF;&#x795E;&#x7ECF;&#x5143;&#x7684;&#x8F93;&#x51FA; self.states[&apos;c&apos;] = self._init_weights([w0,1]) # &#x72B6;&#x6001; def _init_weights(self,shape): return tf.Variable(tf.random_normal(shape, stddev=0.01)) def _calculate(self,step): # &#x5411;&#x524D;&#x66F4;&#x65B0;&#x5404;&#x4E2A;&#x53C2;&#x6570; xc = tf.concat([self.x[step][:,tf.newaxis],self.states[&apos;h&apos;]],0) sigmoid = tf.nn.sigmoid tanh = tf.nn.tanh self.states[&apos;f&apos;] = sigmoid(tf.matmul(self.params[&apos;wf&apos;],xc)) self.states[&apos;i&apos;] = sigmoid(tf.matmul(self.params[&apos;wi&apos;],xc)) self.states[&apos;a&apos;] = tanh(tf.matmul(self.params[&apos;wa&apos;],xc)) self.states[&apos;o&apos;] = sigmoid(tf.matmul(self.params[&apos;wo&apos;],xc)) self.states[&apos;c&apos;] = self.states[&apos;c&apos;] * self.states[&apos;f&apos;] + self.states[&apos;i&apos;] * self.states[&apos;a&apos;] # &#x5BF9;&#x5E94;&#x4F4D;&#x7F6E;&#x4E58; self.states[&apos;h&apos;] = self.states[&apos;o&apos;] * tanh(self.states[&apos;c&apos;]) # &#x5BF9;&#x5E94;&#x4F4D;&#x7F6E;&#x4E58;class Model(): def __init__(self,config): self.cell = LSTMCell(config) outputs = [] with tf.variable_scope(&quot;LSTM&quot;): for step in range(self.cell.time_step): # if step &gt; 0: #&#x7B2C;&#x4E8C;&#x6B21;&#x5FAA;&#x73AF;&#x5F00;&#x59CB;&#xFF0C;&#x4F7F;&#x7528;tf.get_variable_scope().reuse_variables()&#x8BBE;&#x7F6E;&#x590D;&#x7528;&#x53D8;&#x91CF; # tf.get_variable_scope().reuse_variables() self.cell._calculate(step) outputs.append(self.cell.states[&apos;h&apos;]) #&#x6DFB;&#x52A0;&#x5230;&#x8F93;&#x51FA;&#x5217;&#x8868;outputs # output = tf.reshape(tf.concat(outputs, 1), [-1, self.cell.num_hidden]) output = self.cell.states[&apos;h&apos;] #&#x5B9A;&#x4E49;&#x6743;&#x91CD; softmax_w = tf.get_variable( &quot;softmax_w&quot;, [self.cell.embedding,self.cell.num_hidden], dtype=tf.float32) #&#x5B9A;&#x4E49;&#x504F;&#x7F6E; softmax_b = tf.get_variable( &quot;softmax_b&quot;, [self.cell.embedding], dtype=tf.float32) #&#x8F93;&#x51FA;&#x4E58;&#x4E0A;&#x6743;&#x91CD;&#x5E76;&#x52A0;&#x4E0A;&#x504F;&#x7F6E;&#x5F97;&#x5230;logits&#xFF0C;&#x5373;&#x7F51;&#x7EDC;&#x6700;&#x540E;&#x7684;&#x8F93;&#x51FA; self.logits = tf.matmul(softmax_w,output) + softmax_b labels = config.y self.loss = tf.reduce_sum((self.logits - labels) ** 2) self.train_op = tf.train.AdamOptimizer(0.01).minimize(self.loss)def run(x,y,config,max_epoch=100): # x &#x8868;&#x793A;&#x6240;&#x6709;&#x7684;&#x8BAD;&#x7EC3;&#x6570;&#x636E; # y &#x8868;&#x793A;&#x5BF9;&#x5E94;&#x7684;&#x6807;&#x7B7E; start_time = time.time() #&#x8BB0;&#x5F55;&#x5F53;&#x524D;&#x65F6;&#x95F4; costs = 0.0 #&#x521D;&#x59CB;&#x5316;&#x635F;&#x5931;costs iters = 0 #&#x521D;&#x59CB;&#x5316;&#x8FED;&#x4EE3;&#x6570; pred = [] with tf.Graph().as_default(): x_ = tf.placeholder(tf.float32, [config.time_step,config.embedding],name=&apos;x_&apos;) y_ = tf.placeholder(tf.float32, [config.embedding],name=&apos;y_&apos;) config.x = x_ config.y = y_ model = Model(config) feches = { #&#x8F93;&#x51FA;&#x7ED3;&#x679C;&#x7684;&#x5B57;&#x5178;&#x8868; &quot;cost&quot;:model.loss, &quot;op&quot;:model.train_op, &quot;logits&quot;:model.logits } session = tf.Session(config=tf.ConfigProto(log_device_placement=False)) saver = tf.train.Saver(tf.trainable_variables(), max_to_keep=3) with session.as_default(): session.run(tf.global_variables_initializer()) # session.run(tf.initialize_all_variables()) for epoch in range(max_epoch): #&#x8BAD;&#x7EC3;&#x5FAA;&#x73AF; # &#x83B7;&#x5F97;&#x6570;&#x636E; temp = [] for one_x,one_y in zip(x,y): iters+=1 feed_dict = {x_:one_x[:,np.newaxis],y_:[one_y]} vals = session.run(feches, feed_dict) cost = vals[&quot;cost&quot;] logits = vals[&quot;logits&quot;] temp.append(logits[0]) if epoch == max_epoch-1: pred.append(logits[0]) if epoch %2 ==0 : saver.save(session, &apos;LSTM_model/model&apos;, global_step=epoch) print(&apos;cost:{}&apos;.format(cost)) # print(&apos;logits:{} y:{}&apos;.format(logits,one_y)) # if epoch %7==0: # plt.plot(temp) # plt.show() return preddef create_dataset(dataset, look_back=1): dataX, dataY = [], [] for i in range(len(dataset)-look_back-1): a = dataset[i:(i+look_back), 0] dataX.append(a) dataY.append(dataset[i + look_back, 0]) return np.array(dataX), np.array(dataY)class Config(): num_hidden = 4 time_step = 1 embedding = 1 if __name__ == &apos;__main__&apos;: dataset = pd.read_csv(&apos;../data/international-airline-passengers.csv&apos;, usecols=[1], engine=&apos;python&apos;, skipfooter=0) dataset = dataset.values dataset = dataset.astype(&apos;float32&apos;) scaler = MinMaxScaler(feature_range=(0, 1)) dataset = scaler.fit_transform(dataset) config = Config() trainX,trainY = create_dataset(dataset,config.time_step) # print(trainX,trainY) pred = run(trainX,trainY,config) plt.plot(dataset) plt.plot(pred) print(len(dataset),len(pred)) plt.show() &#x7ED3;&#x679C;&#x4E0D;&#x662F;&#x5F88;&#x597D;&#xFF0C; &#x53C2;&#x8003;http://colah.github.io/posts/2015-08-Understanding-LSTMs/https://www.cnblogs.com/wangduo/p/6773601.html?utm_source=itdadao&amp;utm_medium=referralhttps://www.zhihu.com/question/41949741]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>LSTM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刷题-根据前序和中序构建树]]></title>
    <url>%2Fblog%2F2019%2F03%2F14%2F%E5%88%B7%E9%A2%98%2F%E5%88%B7%E9%A2%98-%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[&#x9898;&#x76EE;&#x63CF;&#x8FF0;&#x8F93;&#x5165;&#x67D0;&#x4E8C;&#x53C9;&#x6811;&#x7684;&#x524D;&#x5E8F;&#x904D;&#x5386;&#x548C;&#x4E2D;&#x5E8F;&#x904D;&#x5386;&#x7684;&#x7ED3;&#x679C;&#xFF0C;&#x8BF7;&#x91CD;&#x5EFA;&#x51FA;&#x8BE5;&#x4E8C;&#x53C9;&#x6811;&#x3002;&#x5047;&#x8BBE;&#x8F93;&#x5165;&#x7684;&#x524D;&#x5E8F;&#x904D;&#x5386;&#x548C;&#x4E2D;&#x5E8F;&#x904D;&#x5386;&#x7684;&#x7ED3;&#x679C;&#x4E2D;&#x90FD;&#x4E0D;&#x542B;&#x91CD;&#x590D;&#x7684;&#x6570;&#x5B57;&#x3002;&#x4F8B;&#x5982;&#x8F93;&#x5165;&#x524D;&#x5E8F;&#x904D;&#x5386;&#x5E8F;&#x5217;{1,2,4,7,3,5,6,8}&#x548C;&#x4E2D;&#x5E8F;&#x904D;&#x5386;&#x5E8F;&#x5217;{4,7,2,1,5,3,8,6}&#xFF0C;&#x5219;&#x91CD;&#x5EFA;&#x4E8C;&#x53C9;&#x6811;&#x5E76;&#x8FD4;&#x56DE;&#x3002; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) { struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode)); root-&gt;val = pre[0]; vector&lt;int&gt;::iterator iter; int index = 0; if( pre.size() == 1){ root-&gt;left = NULL; root-&gt;right = NULL; return root; } for (iter=vin.begin();iter!=vin.end();iter++){ if (*iter == root-&gt;val){ if (index == 0){ // &#x65E0;&#x5DE6;&#x5B50;&#x6811; vector&lt;int&gt; pre_in; vector&lt;int&gt; vin_in; pre_in.assign(pre.begin()+index+1,pre.end()); vin_in.assign(iter+1,vin.end());//&#x957F;&#x5EA6;&#x4E3A;1 &#x53EF;&#x80FD;&#x4F1A;&#x51FA;bug root-&gt;left = NULL; root-&gt;right = reConstructBinaryTree(pre_in,vin_in); }else if (index == vin.size()-1){ //&#x65E0;&#x53F3;&#x5B50;&#x6811; vector&lt;int&gt; pre_in; vector&lt;int&gt; vin_in; pre_in.assign(pre.begin()+1,pre.begin()+index+1); vin_in.assign(vin.begin(),iter); root-&gt;left = reConstructBinaryTree(pre_in,vin_in); root-&gt;right = NULL; }else{ vector&lt;int&gt; pre_in_left; vector&lt;int&gt; vin_in_left; vector&lt;int&gt; pre_in_right; vector&lt;int&gt; vin_in_right; pre_in_left.assign(pre.begin()+1,pre.begin()+index+1); vin_in_left.assign(vin.begin(),iter); pre_in_right.assign(pre.begin()+index+1,pre.end()); vin_in_right.assign(iter+1,vin.end()); root-&gt;left = reConstructBinaryTree(pre_in_left,vin_in_left); root-&gt;right = reConstructBinaryTree(pre_in_right,vin_in_right); } break; } index++; } return root; }};]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刷题-纸牌题]]></title>
    <url>%2Fblog%2F2019%2F03%2F14%2F%E5%88%B7%E9%A2%98%2F%E5%88%B7%E9%A2%98-%E7%BA%B8%E7%89%8C%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&#x9898;&#x76EE;&#x8FDE;&#x63A5;&#x95EE;&#x9898;&#x63CF;&#x8FF0; &#x684C;&#x4E0A;&#x6709;&#x4E00;&#x53E0;&#x7EB8;&#x724C;&#xFF0C;&#x5171;n&#x5F20;&#x724C;&#x3002;&#x4ECE;&#x4F4D;&#x4E8E;&#x9876;&#x7AEF;&#x7684;&#x7EB8;&#x724C;&#x5F00;&#x59CB;&#x4ECE;&#x4E0A;&#x5F80;&#x4E0B;&#x4F9D;&#x6B21;&#x7F16;&#x53F7;&#x4E3A;1&#x5230;n&#x3002;&#x73B0;&#x5728;&#x53CD;&#x590D;&#x8FDB;&#x884C;&#x4EE5;&#x4E0B;&#x64CD;&#x4F5C;&#xFF1A;&#x628A;&#x4F4D;&#x4E8E;&#x9876;&#x7AEF;&#x7684;&#x724C;&#x6254;&#x6389;&#xFF0C;&#x7136;&#x540E;&#x628A;&#x65B0;&#x7684;&#x4F4D;&#x4E8E;&#x9876;&#x7AEF;&#x7684;&#x724C;&#x653E;&#x5230;&#x6574;&#x53E0;&#x724C;&#x7684;&#x5E95;&#x90E8;&#x3002;&#x76F4;&#x5230;&#x53EA;&#x5269;&#x4E0B;&#x4E00;&#x5F20;&#x724C;&#x3002;&#x8F93;&#x5165;n(&lt;=1000000)&#xFF0C;&#x8F93;&#x51FA;&#x6BCF;&#x6B21;&#x6254;&#x6389;&#x7684;&#x724C;&#x7684;&#x7F16;&#x53F7;&#x4EE5;&#x53CA;&#x6700;&#x540E;&#x5269;&#x4E0B;&#x7684;&#x724C;&#x7684;&#x7F16;&#x53F7;&#x3002; &#x8F93;&#x5165;&#x683C;&#x5F0F; &#x4E00;&#x4E2A;&#x6574;&#x6570;n &#x8F93;&#x51FA;&#x683C;&#x5F0F; &#x4E00;&#x884C;&#xFF0C;n&#x4E2A;&#x7A7A;&#x683C;&#x95F4;&#x9694;&#x7684;&#x6574;&#x6570;&#xFF0C;&#x8868;&#x793A;&#x9898;&#x76EE;&#x6240;&#x6C42;&#x7684;&#x7F16;&#x53F7; &#x6837;&#x4F8B;&#x8F93;&#x5165; 7 &#x6837;&#x4F8B;&#x8F93;&#x51FA; 1 3 5 7 4 2 6 &#x7528;&#x53CC;&#x94FE;&#x8868;&#x505A;&#x601D;&#x8DEF;&#x4E0A;&#x5F88;&#x7B80;&#x5355; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;using namespace std;struct node{ node * next =NULL; node * pre = NULL; int index;};node * init(int n){ // &#x6784;&#x5EFA;&#x5FAA;&#x73AF;&#x94FE;&#x8868; node * head = NULL; node * p = NULL; node * tear = NULL; for(int i=1;i&lt;=n;i++){ p = new node; p-&gt;index = i; if(NULL == head){ head = p; }else{ tear -&gt;next = p; p -&gt;pre = tear; } tear = p; } tear-&gt;next = head; head-&gt;pre = tear; return head;}void deal(node * head){ node * p = head; node * t = head-&gt;pre; while(p-&gt;next !=p){ cout&lt;&lt;p-&gt;index&lt;&lt;&quot; &quot;; t-&gt;next = p-&gt;next; p-&gt;next-&gt;pre = t; t = p-&gt;next; p = p-&gt;next-&gt;next; } cout&lt;&lt;p-&gt;index&lt;&lt;&quot; &quot;&lt;&lt;endl;}void printnode(node *head){ // &#x6253;&#x5370;&#x5FAA;&#x73AF;&#x94FE;&#x8868; node* p = head; //&#x5148;&#x627E;&#x5C3E;&#x90E8; node * q = NULL; while(p-&gt;pre !=head){ cout&lt;&lt; p-&gt;index&lt;&lt;endl; p = p-&gt;pre; }}int main(){ node *head = init(7); deal(head); return 0;}]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>ACM</tag>
        <tag>链表</tag>
        <tag>双链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刷题-回形矩阵]]></title>
    <url>%2Fblog%2F2019%2F03%2F14%2F%E5%88%B7%E9%A2%98%2F%E5%88%B7%E9%A2%98-%E5%9B%9E%E5%BD%A2%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[&#x9898;&#x76EE;&#x8FDE;&#x63A5;&#x9898;&#x76EE;&#x63CF;&#x8FF0;&#x8F93;&#x5165;&#x4E00;&#x4E2A;&#x77E9;&#x9635;&#xFF0C;&#x6309;&#x7167;&#x4ECE;&#x5916;&#x5411;&#x91CC;&#x4EE5;&#x987A;&#x65F6;&#x9488;&#x7684;&#x987A;&#x5E8F;&#x4F9D;&#x6B21;&#x6253;&#x5370;&#x51FA;&#x6BCF;&#x4E00;&#x4E2A;&#x6570;&#x5B57;&#xFF0C;&#x4F8B;&#x5982;&#xFF0C;&#x5982;&#x679C;&#x8F93;&#x5165;&#x5982;&#x4E0B;4 X 4&#x77E9;&#x9635;&#xFF1A; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 &#x5219;&#x4F9D;&#x6B21;&#x6253;&#x5370;&#x51FA;&#x6570;&#x5B57;1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. &#x601D;&#x8DEF;&#x6BCF;&#x6B21;&#x5C06;&#x77E9;&#x9635;&#x9006;&#x65F6;&#x9488;&#x65CB;&#x8F6C;90&#x5EA6;&#xFF0C;&#x7136;&#x540E;&#x8F93;&#x51FA;&#x7B2C;&#x4E00;&#x884C;&#x3002;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution {public: vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) { vector&lt;int&gt; re; while(matrix.size()){ vector&lt;int&gt; front = matrix.front(); for(int i=0;i&lt;front.size();i++){ re.push_back(front[i]); } matrix.erase(matrix.begin()); if(matrix.size()==0){ break; } matrix = R(matrix); } return re; } vector&lt;vector&lt;int&gt; &gt; R(vector&lt;vector&lt;int&gt; &gt; m){ //&#x9006;&#x8F6C;&#x7F6E; vector&lt;vector&lt;int&gt; &gt; re; int row = m.size(); int col = m[0].size(); for(int i=0;i&lt;col;i++){ vector&lt;int&gt; li; for(int j=0;j&lt;row;j++){ li.push_back(m[j][col-i-1]); } re.push_back(li); } return re; } void printM(vector&lt;vector&lt;int&gt; &gt; m){ for(int i=0;i&lt;m.size();i++){ for(int j=0;j&lt;m[0].size();j++){ cout&lt;&lt;m[i][j]&lt;&lt;&quot;\t&quot;; } cout&lt;&lt;endl; } }};int main(){ Solution s; vector&lt;vector&lt;int&gt; &gt; m; for(int i=0;i&lt;4;i++){ vector&lt;int&gt; li; for(int j=1;j&lt;5;j++){ li.push_back(i*4 + j); } m.push_back(li); } s.printM(m); // m = s.R(m); vector&lt;int&gt; ll = s.printMatrix(m); for(int i=0;i&lt;ll.size();i++){ cout&lt;&lt;ll[i]&lt;&lt;&quot;\t&quot;; } return 0;} &#x5176;&#x4ED6;&#x4E24;&#x4E2A;&#x6BD4;&#x8F83;&#x597D;&#x7684;&#x7B54;&#x6848;&#x94FE;&#x63A5;&#xFF1A;https://www.nowcoder.com/questionTerminal/9b4c81a02cd34f76be2659fa0d54342a&#x6765;&#x6E90;&#xFF1A;&#x725B;&#x5BA2;&#x7F51;12345678910111213141516171819202122class Solution { int n, m; vector&lt;vector&lt;bool&gt; &gt; v; bool judge(int i, int j){ return 0 &lt;= i &amp;&amp; i &lt; n &amp;&amp; 0 &lt;= j &amp;&amp; j &lt; m &amp;&amp; !v[i][j]; }public: vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; a) { vector&lt;int&gt; r; if(!(n = a.size()) || !(m = a[0].size())) return r; v = vector&lt;vector&lt;bool&gt; &gt;(n, vector&lt;bool&gt;(m, false)); const int D[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; int i = 0, j = 0, d = 0, T = m * n; while(T--){ r.push_back(a[i][j]); v[i][j] = true; if(!judge(i + D[d][0], j + D[d][1])) (++d) %= 4; //&#x8F6C;&#x5F2F; i += D[d][0], j += D[d][1];//&#x524D;&#x8FDB; } return r; }}; ####################################################################&#x94FE;&#x63A5;&#xFF1A;https://www.nowcoder.com/questionTerminal/9b4c81a02cd34f76be2659fa0d54342a&#x6765;&#x6E90;&#xFF1A;&#x725B;&#x5BA2;&#x7F51;1234567891011121314151617181920212223242526class Solution {public: vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) { int row = matrix.size(); int col = matrix[0].size(); vector&lt;int&gt; result; // &#x8F93;&#x5165;&#x7684;&#x4E8C;&#x7EF4;&#x6570;&#x7EC4;&#x975E;&#x6CD5;&#xFF0C;&#x8FD4;&#x56DE;&#x7A7A;&#x7684;&#x6570;&#x7EC4; if (row == 0 || col == 0) return result; int top = 0, left = 0, right = col-1, bottom = row-1; while(top &lt;= bottom &amp;&amp; left&lt;= right){ //left to right for(int i = left; i &lt;= right; ++i) result.push_back(matrix[top][i]); //top tp bottom for(int i = top+1; i &lt;= bottom; ++i) result.push_back(matrix[i][right]); //right to left for(int i = right-1; i &gt;= left &amp;&amp; top &lt; bottom; --i) result.push_back(matrix[bottom][i]); //bottom to top for(int i = bottom-1; i &gt; top &amp;&amp; right &gt; left; --i) result.push_back(matrix[i][left]); ++top; ++left; --right; --bottom; } return result; }};]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>刷题</tag>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础练习之排序算法]]></title>
    <url>%2Fblog%2F2019%2F03%2F14%2F%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%2F%E6%8E%92%E5%BA%8F%2F%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&#x5FEB;&#x901F;&#x6392;&#x5E8F;&#x65F6;&#x95F4;&#x590D;&#x6742;&#x5EA6; O(nlogn) &#x9012;&#x5F52;&#x7248;1234567891011121314151617181920212223int partition(int arr[], int left, int right){ int pivotKey = arr[left]; while(left &lt; right) { while(left &lt; right &amp;&amp; arr[right] &gt;= pivotKey) right --; arr[left] = arr[right]; //&#x628A;&#x5C0F;&#x7684;&#x79FB;&#x52A8;&#x5230;&#x5DE6;&#x8FB9; while(left &lt; right &amp;&amp; arr[left] &lt;= pivotKey) left ++; arr[right] = arr[left]; //&#x628A;&#x5927;&#x7684;&#x79FB;&#x52A8;&#x5230;&#x53F3;&#x8FB9; } arr[left] = pivotKey; //&#x6700;&#x540E;&#x628A;pivotKey&#x8D4B;&#x503C;&#x5230;&#x4E2D;&#x95F4; return left;} void quickSort(int arr[], int left, int right) { if(left &gt;= right) return ; int pivotPos = partition(arr, left, right); quickSort(arr, left, pivotPos-1); quickSort(arr, pivotPos+1, right);} &#x975E;&#x9012;&#x5F52;&#x7248;1234567891011121314151617181920212223242526//&#x975E;&#x9012;&#x5F52;&#x7248; --&#x8FED;&#x4EE3;void quickSort(int *base,int start,int end){ const int stacksize=1000; int *stack=new int[stacksize]; int top=0; stack[top++]=start; stack[top++]=end-start+1; while(top!=0) { //cout&lt;&lt;top&lt;&lt;endl; top--; int r=stack[top]; top--; int p=stack[top]; if(p&gt;=r) continue; int m=partition(base,p,r); //push the left stack[top++]=p; stack[top++]=m-1; //push the right stack[top++]=m+1; stack[top++]=r; }} &#x7EE7;&#x7EED;&#x8865;&#x5145;&#x4E2D;&#x3002;&#x3002;&#x3002;&#x53C2;&#x8003;&#x9762;&#x8BD5;&#x4E2D;&#x7684;&#x6392;&#x5E8F;&#x7B97;&#x6CD5;&#x603B;&#x7ED3;]]></content>
      <categories>
        <category>基础算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo在多个电脑上写文章]]></title>
    <url>%2Fblog%2F2019%2F03%2F12%2F%E9%83%A8%E7%BD%B2%2Fhexo%E5%9C%A8%E5%A4%9A%E4%B8%AA%E7%94%B5%E8%84%91%E4%B8%8A%E5%86%99%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#x4E4B;&#x524D;&#x7528;hexo&#x8BD5;&#x4E86;&#x8BD5;&#x6C34;,&#x5F53;&#x65F6;&#x611F;&#x89C9;hexo&#x5199;&#x6587;&#x7AE0;&#x5E76;&#x90E8;&#x7F72;&#x5230;github&#x633A;&#x65B9;&#x4FBF;&#x7684;&#xFF0C;&#x4F46;&#x662F;&#x6CA1;&#x5565;&#x5199;&#x7684;&#x5C31;&#x653E;&#x4E0B;&#x4E86;&#x3002;&#x534A;&#x5E74;&#x540E;&#x611F;&#x89C9;&#x8981;&#x5F00;&#x59CB;&#x5199;&#x70B9;&#x4E1C;&#x897F;&#x4E86;&#x3002;&#x51C6;&#x5907;&#x5199;&#x65F6;&#x5C31;&#x53D1;&#x73B0;&#x4E86;&#x4E2A;&#x95EE;&#x9898;&#xFF0C;&#x600E;&#x4E48;&#x5728;&#x591A;&#x4E2A;&#x8BBE;&#x5907;&#x4E4B;&#x95F4;&#x540C;&#x6B65;&#x3002;&#x641C;&#x4E86;&#x5F88;&#x591A;&#x6559;&#x7A0B;&#xFF0C;&#x89C9;&#x5F97;&#x8FD9;&#x4E2A;&#x6559;&#x7A0B; &#x8FD8;&#x53EF;&#x4EE5;&#xFF0C;&#x5C31;&#x662F;&#x8BF4;&#x7684;&#x6709;&#x70B9;&#x7B80;&#x5355;&#x4E86;&#x3002; &#x524D;&#x63D0;&#x6761;&#x4EF6; &#x5FC5;&#x987B;&#x6709;hexo&#x7684;&#x5168;&#x90E8;&#x5DE5;&#x7A0B;&#x6587;&#x4EF6;&#xFF0C;&#x5982;&#x679C;&#x53EA;&#x6709;&#x4E4B;&#x524D;&#x4E0A;&#x4F20;&#x5728;github&#x7684;&#x6587;&#x7AE0;&#xFF0C;&#x90A3;&#x53EA;&#x80FD;&#x65B0;&#x5EFA;hexo&#x9879;&#x76EE;&#x4E86;&#x3002; &#x539F;&#x7406; git &#x7BA1;&#x7406;&#x4E24;&#x4E2A;&#x5206;&#x652F;&#xFF0C;&#x4E00;&#x4E2A;master&#x5206;&#x652F;&#xFF0C;&#x4E00;&#x4E2A;src&#x5206;&#x652F;&#x3002;master&#x5206;&#x652F;&#x7531;src&#x5206;&#x652F;&#x901A;&#x8FC7;hexo g -d &#x751F;&#x6210;&#x5E76;&#x4E0A;&#x4F20;&#x5230;&#x8FDC;&#x7AEF;&#x3002;src&#x5206;&#x652F;&#x4FDD;&#x7559;&#x5DE5;&#x7A0B;&#x5FC5;&#x987B;&#x7684;&#x6587;&#x4EF6;&#xFF0C;&#x4EE5;&#x4FBF;&#x5728;&#x5176;&#x4ED6;&#x7535;&#x8111;clone&#x540E;&#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x5199;&#x6587;&#x7AE0;&#x3002; &#x5F00;&#x59CB; &#x5728;blog&#x76EE;&#x5F55;&#x4E0B;&#x5EFA;&#x7ACB;&#x4E00;&#x4E2A;src&#x5206;&#x652F; git checkout -b srcgit branch &#x53EF;&#x4EE5;&#x67E5;&#x770B;&#x5F53;&#x524D;&#x7684;&#x5206;&#x652F; &#x6DFB;&#x52A0;&#x5168;&#x90E8; git add . &#x63D0;&#x4EA4;&#x5230;&#x672C;&#x5730; git commmit -m &#x201C;&#x65B0;&#x5EFA;&#x6E90;&#x5206;&#x652F;&#x201D; &#x63A8;&#x9001;&#x5230;github (&#x8FD9;&#x4E00;&#x6B65;&#x53EF;&#x80FD;&#x4F1A;&#x8981;&#x6C42;&#x8F93;&#x5165;github&#x8D26;&#x53F7;&#x548C;&#x5BC6;&#x7801;) git push origin src &#x600E;&#x4E48;&#x4F7F;&#x7528;&#x5462;&#x3002; &#x5728;&#x53E6;&#x4E00;&#x4E2A;&#x8BBE;&#x5907;&#x4E0A;&#x514B;&#x9686;src&#x5206;&#x652F; git clone -b src https://github.com/XXX/blog.git &#x56E0;&#x4E3A;&#x4E4B;&#x524D;&#x4E0A;&#x4F20;&#x7684;&#x9879;&#x76EE;&#x662F;&#x6CA1;&#x6709;&#x6A21;&#x5757;&#x7684;&#xFF0C;&#x6B64;&#x65F6;&#x8FD8;&#x9700;&#x8981;&#x5B89;&#x88C5;hexo &#x6A21;&#x5757; npm install(&#x6211;&#x5ACC;npm&#x592A;&#x6162;&#xFF0C;&#x7528;&#x7684;&#x6DD8;&#x5B9D;&#x7684;cnpm install) &#x4E4B;&#x540E;&#x5C31;&#x53EF;&#x4EE5;&#x5728;source/_post&#x4E0B;&#x5199;&#x6587;&#x7AE0;&#x4E86;&#x3002; &#x53D1;&#x5E03;&#x8FD8;&#x662F; hexo g -d &#x5199;&#x5B8C;&#x540E;&#x8981;&#x5C06;&#x6E90;&#x6587;&#x4EF6;&#x4E0A;&#x4F20; &#x5728;blog&#x76EE;&#x5F55;&#x4E0B; git add . git commit -m &#x201C;&#x65B0;&#x589E;&#x4E86;&#x7BC7;&#x6587;&#x7AE0;&#x201D; git push origin src &#x5927;&#x529F;&#x544A;&#x6210; &#x53EF;&#x80FD;&#x9047;&#x5230;&#x7684;&#x95EE;&#x9898; WARN No layout: index.html &#x8FD9;&#x662F;&#x7531;&#x4E8E;&#x4E3B;&#x9898;&#x6587;&#x4EF6;&#x7F3A;&#x5931;&#x9020;&#x6210;&#x7684;&#xFF0C;&#x6709;&#x4E24;&#x79CD;&#x65B9;&#x6CD5;&#x89E3;&#x51B3;&#x3002; &#x76F4;&#x63A5;&#x62F7;&#x8D1D;&#x4E00;&#x4EFD;&#x76F8;&#x5173;&#x4E3B;&#x9898;&#x6587;&#x4EF6;&#x5230;&#x9879;&#x76EE;&#x7684;theme&#x76EE;&#x5F55;&#x4E0B;&#x9762;12$ cd your-hexo-site$ git clone https://github.com/mrcat2018/hexo-theme-next.git themes/next &#x8FD9;&#x6837;&#x505A;&#xFF0C;&#x6BCF;&#x6B21;&#x5728;&#x65B0;&#x7684;&#x8BBE;&#x5907;&#x4E0A;&#x90FD;&#x5F97;&#x62F7;&#x8D1D;&#x4E00;&#x4EFD;&#xFF0C;&#x5982;&#x679C;&#x4FEE;&#x6539;&#x4E86;&#x4E3B;&#x9898;&#x7684;&#x6837;&#x5F0F;&#xFF0C;&#x8FD8;&#x4E0D;&#x4F1A;&#x540C;&#x6B65;&#x5230;github&#x4E0A;&#xFF0C;&#x53EA;&#x4F1A;&#x540C;&#x6B65;&#x5230;&#x6587;&#x7AE0;&#x53D1;&#x5E03;&#x7684;master&#x5206;&#x652F;&#x4E0A;&#x3002;&#x4E0D;&#x63A8;&#x8350; &#x81EA;&#x5DF1;&#x5148;fork&#x4E00;&#x4EFD;&#x4E3B;&#x9898;&#x6587;&#x4EF6;&#x5230;&#x81EA;&#x5DF1;&#x7684;&#x8FDC;&#x7AEF;&#x4ED3;&#x5E93;&#xFF0C;&#x7136;&#x540E;&#x7ED9;blog&#x9879;&#x76EE;&#x6DFB;&#x52A0;&#x5B50;&#x6A21;&#x5757;&#x3002;&#x600E;&#x4E48;fork&#x5C31;&#x4E0D;&#x8BF4;&#x4E86;&#x3002;12$ cd your-hexo-site$ git submodule add https://github.com/mrcat2018/hexo-theme-next.git themes/next &#x8FD9;&#x6837;&#x4FEE;&#x6539;&#x6837;&#x5F0F;&#x540E;&#x53EF;&#x4EE5;&#x63D0;&#x4EA4;&#x5230;&#x8FDC;&#x7AEF;&#x4ED3;&#x5E93;&#xFF0C;&#x4FDD;&#x8BC1;&#x6BCF;&#x6B21;clone&#x65F6;&#x90FD;&#x662F;&#x81EA;&#x5DF1;&#xFF08;&#x53EF;&#x80FD;&#x505A;&#x8FC7;&#x4FEE;&#x6539;&#xFF09;&#x7684;&#x4E3B;&#x9898; clone &#x65F6;&#x7684;&#x52A0;&#x4E0A; &#x2013;recursive 1git clone -b src https://github.com/XXX/blog.git --recursive fatal: in unpopulated submodule &#x2018;.deploy_git&#x2019; &#x4E00;&#x822C;&#x6267;&#x884C;&#x8FC7;npm install &#x90FD;&#x4F1A;&#x76F4;&#x63A5;&#x5728;&#x9879;&#x76EE;&#x7684;&#x4F9D;&#x8D56;&#x5305;&#x4E2D;&#x5B89;&#x88C5;&#x4E86;hexo-deployer-git&#x7684;&#xFF0C;&#x5148;&#x8003;&#x8651;&#x662F;&#x4E0D;&#x662F;git&#x7F13;&#x5B58;&#x4E0D;&#x4E00;&#x81F4;&#x9020;&#x6210;&#x7684;&#x3002; 1git rm -r --cached .deploy_git &#x8FD8;&#x662F;&#x4E0D;&#x884C;&#x90A3;&#x53EF;&#x80FD;&#x662F;&#x5305;&#x6CA1;&#x5B89;&#x88C5; 1cnpm install hexo-deployer-git &#x2013;save]]></content>
      <categories>
        <category>部署</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 添加远程子模块]]></title>
    <url>%2Fblog%2F2019%2F03%2F12%2F%E9%83%A8%E7%BD%B2%2F%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E5%AD%90%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[12$ cd your-hexo-site$ git submodule add https://github.com/iissnan/hexo-theme-next themes/next &#x5982;&#x679C;clone &#x5FD8;&#x8BB0;&#x52A0; &#x2013;recursive ,&#x5B50;&#x6A21;&#x5757;&#x4E0D;&#x4F1A;&#x4E0B;&#x8F7D;&#x4E0B;&#x6765;,&#x53EF;&#x4EE5;&#x5355;&#x72EC;&#x4E0B;&#x8F7D;&#x5B50;&#x6A21;&#x5757;.1git submodule update --init --recursive]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试文章]]></title>
    <url>%2Fblog%2F2018%2F09%2F23%2F%E6%B5%8B%E8%AF%95%2F%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[&#x8FD9;&#x662F;&#x4E00;&#x7BC7;&#x6D4B;&#x8BD5;&#x6587;&#x7AE0; &#x8BED;&#x6CD5;&#x7B80;&#x4ECB; start&#xFF1A;&#x5F00;&#x59CB;end&#xFF1A;&#x7ED3;&#x675F;operation&#xFF1A;&#x64CD;&#x4F5C;subroutine&#xFF1A;&#x5B50;&#x7A0B;&#x5E8F;condition&#xFF1A;&#x6761;&#x4EF6;&#x5224;&#x65AD;inputoutput&#xFF1A;&#x8F93;&#x5165;&#x8F93;&#x51FA; graph LR; A---B B--&gt;C[fa:fa-ban forbidden] B--&gt;D(fa:fa-spinner) C=&gt;D 1212 graph TD; A--&gt;|B|E; A--&gt;|C|E; E--&gt;D graph TB; A--&gt;B A--&gt;C; B--&gt;D; B--&gt;E; graph TD client1--&gt;|read / write|SVN((SVN server)) client2--&gt;|read only|SVN client3--&gt;|read / write|SVN client4--&gt;|read only|SVN client5(...)--&gt;SVN SVN---|store the data|sharedrive st=&gt;start: Start|past:&gt;http://www.google.com[blank] e=&gt;end: End:&gt;http://www.google.com op1=&gt;operation: My Operation|past op2=&gt;operation: Stuff|current sub1=&gt;subroutine: My Subroutine|invalid cond=&gt;condition: Yes or No?|approved:&gt;http://www.google.com c2=&gt;condition: Good idea|rejected io=&gt;inputoutput: catch something...|request st-&gt;op1(right)-&gt;cond cond(yes, right)-&gt;c2 cond(no)-&gt;sub1(left)-&gt;op1 c2(yes)-&gt;io-&gt;e c2(no)-&gt;op2-&gt;e{&quot;theme&quot;:&quot;simple&quot;,&quot;scale&quot;:1,&quot;line-width&quot;:2,&quot;line-length&quot;:50,&quot;text-margin&quot;:10,&quot;font-size&quot;:12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);Diagram loop Daily query Alice-&gt;&gt;Bob: Hello Bob, how are you? alt is sick Bob-&gt;&gt;Alice: Not so good :( else is well Bob-&gt;&gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-&gt;&gt;Alice: Thanks for asking end end{&quot;theme&quot;:&quot;simple&quot;,&quot;scale&quot;:1,&quot;line-width&quot;:2,&quot;line-length&quot;:50,&quot;text-margin&quot;:10,&quot;font-size&quot;:12} var code = document.getElementById("sequence-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value)); var diagram = Diagram.parse(code); diagram.drawSVG("sequence-0", options);Title:&#x8FDE;&#x63A5;&#x5EFA;&#x7ACB;&#x7684;&#x8FC7;&#x7A0B; &#x5BA2;&#x6237;&#x4E3B;&#x673A;-&gt;&#x670D;&#x52A1;&#x5668;&#x4E3B;&#x673A;: &#x8FDE;&#x63A5;&#x8BF7;&#x6C42;&#xFF08;SYN=1,seq=client_isn&#xFF09; &#x670D;&#x52A1;&#x5668;&#x4E3B;&#x673A;-&gt;&#x5BA2;&#x6237;&#x4E3B;&#x673A;: &#x6388;&#x4E88;&#x8FDE;&#x63A5;&#xFF08;SYN=1,seq=client_isn&#xFF09;\n ack=client_isn+1 &#x5BA2;&#x6237;&#x4E3B;&#x673A;-&gt;&#x670D;&#x52A1;&#x5668;&#x4E3B;&#x673A;: &#x786E;&#x8BA4;&#xFF08;SYN=0,seq=client_isn+1&#xFF09;\nack=server_isn+1{&quot;theme&quot;:&quot;simple&quot;,&quot;scale&quot;:1,&quot;line-width&quot;:2,&quot;line-length&quot;:50,&quot;text-margin&quot;:10,&quot;font-size&quot;:12} var code = document.getElementById("sequence-1-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-1-options").value)); var diagram = Diagram.parse(code); diagram.drawSVG("sequence-1", options);]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试tag</tag>
        <tag>git</tag>
      </tags>
  </entry>
</search>
